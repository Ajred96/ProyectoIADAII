%%%%%%% PAQUETES Y CONFIGURACIONES %%%%%%% INICIO
\documentclass[11pt,letter]{article}

% Idioma y codificación
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}

% Diseño de página
\usepackage[left=2.54cm,right=2.54cm,top=2.54cm,bottom=2.54cm]{geometry}
\usepackage{setspace}
\usepackage{float}

% Tipografía y matemáticas
\usepackage{amsmath}
\usepackage{pifont}

% Colores (debe ir antes de tcolorbox y pgfplots)
\usepackage[table,xcdraw]{xcolor}

% Gráficos y figuras
\usepackage{graphicx}
\usepackage{pgfplots}
\pgfplotsset{compat=1.18}

% Tablas y cajas
\usepackage{booktabs}
\usepackage[most]{tcolorbox}
\usepackage{mdframed}

% Algoritmos y código
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{listings}

% Referencias y notas
\usepackage{nameref}
\usepackage{natbib}
\usepackage{endnotes}

% Hipervínculos (último siempre que sea posible)
\usepackage{hyperref}

%%%%%%% PAQUETES Y CONFIGURACIONES %%%%%%% FIN


\begin{document}
\onehalfspacing

%%%%%%% PORTADA %%%%%%% INICIO
\begin{titlepage}
\centering
\includegraphics[width=0.15\textwidth]{resources/universidad-del-valle.png}\par\vspace{1cm}
{\scshape\LARGE Universidad del Valle \par}
{\scshape\Large Facultad de Ingeniería \par}
{\scshape\Large Escuela de Ingeniería de Sistemas y Computación \par}
\vspace{2cm}

{\Large \textbf{Moderando el Conflicto Interno de Opiniones en una Red Social}}\\

\vspace{2cm}
    {\large \textbf{Anderson Johan Alban Angulo - 202310006}}\\
    {\large \textbf{Andrés Felipe Asprilla Urrutia - 202224101 }}\\
    {\large \textbf{Andrés Mauricio Ortiz Bermúdez - 202110330}}\\
    {\large \textbf{Carlos Mauricio Tovar Parra - 201741699}}\\
\vspace{2cm}

    \Large\textbf{Profesor}\par
    {\large \textbf{Jesús Alexander Aranda Bueno Ph.D.}}\\
\vspace{1.4cm}
    \Large\textbf{Curso}\par
    {\large \textbf{Análisis y Diseño de Algoritmos II (750020C)}}\\
\vspace{1cm}
{\large {19 de abril de 2025}\par}
\end{titlepage}
%%%%%%% PORTADA %%%%%%% FIN

%%%%%%% INDICE %%%%%%% INICIO
\tableofcontents
%%%%%%% INDICE %%%%%%% FIN
\newpage

%%%%%%% INTRODUCCIÓN %%%%%%% INICIO
\section{Introducción}

En este proyecto se aborda el problema de la moderación del conflicto interno de opiniones en una red social ficticia, denominada ModCI. Este fenómeno se presenta cuando un mismo individuo sostiene opiniones inconsistentes frente a dos afirmaciones relacionadas con un mismo tema, lo que refleja una falta de coherencia interna. Esta incoherencia puede ser indicativa de una comprensión superficial o confusa del tema, y su presencia generalizada en una red social puede afectar la calidad del debate y la estabilidad de las posturas colectivas.

El objetivo principal del proyecto es diseñar e implementar soluciones algorítmicas que permitan reducir el conflicto interno de la red social, modificando las opiniones de algunos de sus agentes de manera estratégica, teniendo en cuenta el nivel de rigidez de cada uno y un presupuesto limitado de esfuerzo disponible. Para ello, se utilizaron y compararon tres enfoques clásicos del diseño de algoritmos: fuerza bruta, algoritmos voraces y programación dinámica.

Cada enfoque será aplicado al problema ModCI para identificar qué agentes deben ser priorizados en el proceso de ajuste de opinión, con el fin de maximizar la reducción del conflicto interno total en la red. Además de implementar los algoritmos, se realizará un análisis comparativo considerando la optimalidad de las soluciones y la eficiencia computacional de cada estrategia.

Este proyecto busca que los estudiantes pongan en práctica las técnicas aprendidas para enfrentar problemas de naturaleza combinatoria, y que sean capaces de evaluar críticamente las ventajas y limitaciones de diferentes enfoques algorítmicos, tanto desde el punto de vista teórico como práctico.
%%%%%%% INTRODUCCIÓN %%%%%%% FIN

\newpage

%%%%%%% FUNCIONES AUXILIARES %%%%%%% INICIO
\section{Funciones auxiliares}

    Se implementaron varias funciones auxiliares que permiten calcular de manera modular el esfuerzo de moderación aplicado a una red social y el conflicto interno resultante. Estas funciones son esenciales para evaluar cualquier estrategia de solución (fuerza bruta, voraz o dinámica).

    \[
\begin{aligned}
\textbf{CI} &: \text{Conflicto Interno} \\
\mathcal{RS} &: \text{Red Social} \\
o_{i,1} &: \text{Primera opinión del grupo } i \\
o_{i,2} &: \text{Segunda opinión del grupo } i \\
r_i &: \text{Rigidez del grupo } i \\
E &: \text{Estrategia de moderación}
\end{aligned}
\]


    \subsection*{1. \texttt{calcular\_conflicto}}
        Esta función estima el nivel de conflicto interno de una red social, considerando una posible estrategia de moderación. Si no se proporciona una estrategia, se asume que todos los agentes conservan sus opiniones originales. El cálculo sigue la definición de conflicto interno:
        
        \[
        CI(\mathcal{RS}) = \frac{\sum_{i=0}^{n-1} \left(n_i^\mathcal{RS} \ast \left(o_{i,1}^\mathcal{RS} - o_{i,2}^\mathcal{RS}\right)^2\right)}{n}
        \]
        
        donde $e_i$ es la cantidad de agentes moderados del grupo $i$. El conflicto se promedia respecto al número total de grupos
        
        \begin{itemize}
          \item \textbf{Entrada:} \texttt{red\_social} (lista de tuplas), \texttt{estrategia} (lista opcional).
          \item \textbf{Salida:} Valor del conflicto interno (real).
        \end{itemize}
    
    \subsection*{2. \texttt{calcular\_esfuerzo}}
        Calcula el esfuerzo total requerido para aplicar una estrategia de moderación sobre los grupos de la red. El esfuerzo se calcula como:
        
        \[
Esfuerzo(\mathcal{RS}, E) = \sum_{i=0}^{n-1} \left[ \left| o^{\mathcal{RS}}_{i,1} - o^{\mathcal{RS}}_{i,2} \right| * r^{\mathcal{RS}}_i * e_i \right]
\]

        
        \begin{itemize}
          \item \textbf{Entrada:} \texttt{red\_social}, \texttt{estrategia}.
          \item \textbf{Salida:} Esfuerzo total requerido (entero).
        \end{itemize}
    
    \subsection*{3. \texttt{calcular\_ci\_esfuerzo}}
        \label{sec:calcular_ci_esfuerzo}
        Función compuesta que retorna simultáneamente el conflicto interno y el esfuerzo total asociado a una estrategia. Es usada como función de evaluación principal por los tres enfoques de solución.
        
        \begin{itemize}
          \item \textbf{Entrada:} \texttt{red\_social}, \texttt{estrategia}.
          \item \textbf{Salida:} Tupla \texttt{(conflicto, esfuerzo)}.
        \end{itemize}
    
    \subsection*{4. \texttt{extraer\_datos\_red}} 
        Facilita la manipulación de la red social al extraer sus atributos en listas separadas.
        
        \begin{itemize}
          \item \textbf{Entrada:} \texttt{red\_social}.
          \item \textbf{Salida:} Cuádrupla de listas: \texttt{(n, opiniones\_1, opiniones\_2, rigidez)}.
        \end{itemize}

%%%%%%% FUNCIONES AUXILIARES %%%%%%% FIN
\newpage
%%%%%%% FUERZA BRUTA %%%%%%% INICIO
\section{Algoritmo Fuerza Bruta}
\subsection{Descripción}
El enfoque de fuerza bruta para resolver el problema ModCI consiste en examinar exhaustivamente todas las posibles formas en que puede distribuirse el esfuerzo disponible entre los grupos de agentes de una red social, con el fin de minimizar su conflicto interno. Este enfoque parte de la premisa de considerar cada combinación factible de cambios en las opiniones de los agentes, evaluando en cada caso el nivel de conflicto resultante. De todas las estrategias que respetan el límite de esfuerzo permitido, se elige aquella que produce el menor conflicto interno. Al contemplar el espacio completo de soluciones, este método asegura encontrar la solución óptima. No obstante, su principal desventaja radica en el elevado costo computacional que implica, lo que restringe su uso práctico a redes de tamaño reducido.

\subsection{Implementación}
La implementación del algoritmo de fuerza bruta se realizó empleando una representación estructurada de la red social como una lista de tuplas. Cada tupla modela un grupo de agentes e incluye cuatro elementos: la cantidad de individuos en el grupo, sus opiniones frente a dos afirmaciones específicas, y su nivel de rigidez al cambio de opinión.

El proceso se estructura en dos fases principales:

\begin{enumerate}
    \item \textbf{Generación Exhaustiva de Estrategias:} Se construye el conjunto completo de combinaciones posibles de moderación sobre los grupos de agentes. Para cada grupo, se consideran todos los valores enteros desde 0 hasta el número total de agentes del grupo, lo cual representa cuántos de sus miembros podrían modificar su opinión. Al combinar estas posibilidades para todos los grupos, se genera el espacio total de estrategias viables.S
    \item \textbf{Evaluación y Selección de la Mejor Estrategia:} Cada combinación es evaluada mediante la función auxiliar \nameref{sec:calcular_ci_esfuerzo}, la cual calcula tanto el conflicto interno como el esfuerzo requerido para esa estrategia. Si el esfuerzo total no supera el máximo permitido $\mathtt{R_{\text{max}}}$ y el conflicto interno es menor al mejor encontrado hasta el momento, se actualiza la mejor solución.
\end{enumerate}

El resultado final es una tupla que contiene: el conflicto interno mínimo alcanzado, el esfuerzo total utilizado y la estrategia óptima de asignación de esfuerzos.

\subsection{Pseudocódigo}
\begin{algorithm}[H]
\caption{modciFB: Estrategia óptima por fuerza bruta}
\KwIn{Una red social $RS$ como lista de tuplas $(n_i, op1_i, op2_i, rigidez_i)$ para cada grupo $i$, y un esfuerzo máximo permitido $R_{max}$}
\KwOut{Tupla $(CI_{\min}, Esfuerzo_{\text{total}}, Estrategia_{\text{óptima}})$}

$mejorCI \leftarrow \infty$ \tcp*[r]{Inicializa el conflicto mínimo como infinito}
$mejorEsfuerzo \leftarrow 0$ \tcp*[r]{Inicializa el esfuerzo asociado}
$mejorEstrategia \leftarrow []$ \tcp*[r]{Inicializa la mejor estrategia vacía}

$estrategias \leftarrow [[]]$ \tcp*[r]{Lista inicial con una estrategia vacía}

\ForEach{grupo $g_i$ en $RS$}{
    $nuevasEstrategias \leftarrow []$ \\
    \ForEach{estrategia en estrategias}{
        \For{$e \leftarrow 0$ \KwTo $n_i$}{
            $nuevasEstrategias.\text{append}(estrategia + [e])$
        }
    }
    $estrategias \leftarrow nuevasEstrategias$ \tcp*[r]{Actualizar todas las combinaciones}
}

\ForEach{estrategia $E$ en estrategias}{
    $(CI, esfuerzo) \leftarrow calcular\_ci\_esfuerzo(RS, E)$ \\
    \If{$esfuerzo \leq R_{max}$ \textbf{and} $CI < mejorCI$}{
        $mejorCI \leftarrow CI$ \\
        $mejorEsfuerzo \leftarrow esfuerzo$ \\
        $mejorEstrategia \leftarrow E$
    }
}

\Return $(mejorCI, mejorEsfuerzo, mejorEstrategia)$
\end{algorithm}


\definecolor{lightgray}{rgb}{0.9,0.9,0.9}
\lstset{
    language=Python,
    backgroundcolor=\color{lightgray},
    frame=single,
    rulecolor=\color{black}
}

\subsection{Complejidad}
\subsubsection{Complejidad Temporal}

El algoritmo de fuerza bruta tiene una complejidad temporal exponencial, debido a que genera y evalúa todas las posibles combinaciones de esfuerzos para los grupos de la red. Si hay $n$ grupos y cada grupo tiene $k_i$ personas, entonces el número total de combinaciones posibles es:

\[
O\left(\prod_{i=1}^{n}(k_i + 1)\right)
\]

En el peor de los casos, si todos los grupos tienen un tamaño máximo de $k$, la complejidad se puede expresar como:

\[
O\left((k + 1)^n\right)
\]

Además, para cada combinación se evalúa el conflicto interno y el esfuerzo total, lo que implica un recorrido lineal sobre los $n$ grupos. Por lo tanto, la complejidad final del algoritmo es:

\[
O\left(n (k + 1)^n\right)
\]

Esto lo convierte en un algoritmo extremadamente costoso computacionalmente, ya que el tiempo de ejecución crece exponencialmente con el número de grupos y el tamaño de cada uno. Aunque garantiza una solución óptima, este enfoque no es adecuado para instancias grandes del problema.

En términos prácticos, esta complejidad significa que incluso para valores moderados de $n$ y $k$, el número total de combinaciones puede volverse inmanejable. Por ejemplo, si se tienen apenas 10 grupos de tamaño 10, el algoritmo tendría que evaluar $(10 + 1)^{10} = 25937424601$ combinaciones posibles.

\subsubsection{Complejidad Espacial}

La complejidad espacial también es considerable. El algoritmo almacena en memoria todas las combinaciones posibles de esfuerzos antes de evaluarlas. Por tanto, en el peor de los casos, el número de combinaciones almacenadas es:

\[
{O}\left((k+1)^n\right)
\]

donde $n$ es la cantidad de grupos y $k$ el número máximo de agentes por grupo. Esto se debe a que se construye la lista completa de estrategias (vectores de tamaño $n$), en la cual cada componente puede tomar un valor entre $0$ y $k$.

Este costo espacial es resultado del uso de listas auxiliares que mantienen todas las estrategias posibles en memoria antes de su evaluación, lo que puede saturar rápidamente la memoria en problemas con muchos grupos o agentes.

\subsection{Corrección}

El algoritmo de fuerza bruta desarrollado para el problema ModCI garantiza la 
obtención de la solución óptima, ya que evalúa exhaustivamente todas las 
combinaciones posibles de distribución de esfuerzos entre los grupos de la red 
social. Para cada combinación generada, calcula el nivel de conflicto interno 
resultante y verifica que el esfuerzo total no supere el límite máximo permitido. 
Posteriormente, selecciona la estrategia que logra minimizar el conflicto interno 
dentro de las restricciones establecidas. 

Sin embargo, aunque el algoritmo es correcto desde el punto de vista funcional, su 
ejecución implica una búsqueda exhaustiva de soluciones que conlleva una 
complejidad exponencial. A medida que aumenta el número de grupos o el tamaño 
de estos, el número de combinaciones crece de forma drástica, lo cual impacta 
negativamente en el rendimiento. Esto limita su aplicabilidad a redes de pequeño 
tamaño, donde aún es viable computacionalmente. 
Por lo tanto, si bien este enfoque asegura una solución óptima y es útil como 
referencia o para validar la calidad de soluciones aproximadas, no es práctico para 
redes sociales grandes, y por ello es necesario acudir a técnicas más eficientes 
como los algoritmos voraces o la programación dinámica para abordar instancias 
más complejas del problema.

\subsection{Análisis}

A continuación se presenta un análisis concreto que permite ilustrar el funcionamiento paso a paso del algoritmo de fuerza bruta

\textbf{Datos de entrada:}

\begin{table}[ht]
\centering
\begin{tabular}{cccccc}
\toprule
\textbf{Grupo} & \textbf{Agentes} & \textbf{Opinión 1} & \textbf{Opinión 2} & \textbf{Rigidez} \\
\midrule
1 & 1 & -4 & 2 & 0.1 \\
2 & 4 & 1 & -1 & 0.2 \\
3 & 3 & 3 & 0 & 0.5 \\
\bottomrule
$R_{\text{max}} = 5$
\end{tabular}
\caption{Datos entrada: análisis fuerza bruta}
\end{table}


\subsubsection*{Análisis del proceso}
El paso a paso para generar la solución en el algoritmo de fuerza bruta es el siguiente:
\begin{enumerate}
    \item \textbf{Generación de combinaciones posibles}: Se generan todas las combinaciones de esfuerzos posibles para los grupos, respetando el rango desde 0 hasta el número de agentes por grupo.
    
    En este caso:
    \begin{itemize}
        \item Grupo 1: $0$ a $1$ (2 opciones)
        \item Grupo 2: $0$ a $4$ (5 opciones)
        \item Grupo 3: $0$ a $1$ (2 opciones)
    \end{itemize}

    Total de combinaciones: $2 \times 5 \times 2 = 20$

    \item \textbf{Cálculo del conflicto interno (CI)}: Se calcula el conflicto interno para cada combinación válida, considerando cuántos agentes permanecen sin moderar. Usando la función \nameref{sec:calcular_ci_esfuerzo}.
    \item \textbf{Cálculo del esfuerzo total por combinación}: Se calcula el esfuerzo total requerido usando la misma función auxiliar.
    
    \item \textbf{Filtrado por esfuerzo máximo permitido ($R_{\text{max}}$)}: Se descartan combinaciones cuyo esfuerzo supere el valor de $R_{\text{max}} = 5$.

    \item \textbf{Selección de la mejor estrategia}: De las combinaciones válidas, se selecciona la que genere el menor conflicto interno.
\end{enumerate}

\textbf{Combinaciones posibles (20 en total):}

\begin{center}
\renewcommand{\arraystretch}{1.2}
\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{cccc}
\toprule
\textbf{Combinación (G1 - G2 - G3)} & \textbf{Esfuerzo Total} & \textbf{Conflicto Interno} & \textbf{Válida} \\
\midrule
0 - 0 - 0 & 0 & 29.3333 & \ding{51} \\
\rowcolor{gray!10} 0 - 0 - 1 & 1 & 21.3333 & \ding{51} \\
0 - 0 - 2 & 2 & 25.3333 & \ding{51} \\
0 - 1 - 0 & 1 & 27.3333 & \ding{51} \\
0 - 1 - 1 & 2 & 17.3333 & \ding{51} \\
\rowcolor{gray!10} 0 - 2 - 0 & 2 & 21.3333 & \ding{51} \\
0 - 2 - 1 & 3 & 13.3333 & \ding{51} \\
0 - 3 - 0 & 3 & 17.3333 & \ding{51} \\
0 - 3 - 1 & 4 & 9.3333 & \ding{55} \\
0 - 4 - 0 & 4 & 13.3333 & \ding{55} \\
0 - 4 - 1 & 5 & 5.3333 & \ding{55} \\
1 - 0 - 0 & 1 & 25.3333 & \ding{51} \\
\rowcolor{gray!10}\textbf{1 - 0 - 1} & \textbf{6} & \textbf{21.3333} & \ding{72} \\
\rowcolor{gray!10} 1 - 1 - 0 & 2 & 21.3333 & \ding{51} \\
1 - 1 - 1 & 3 & 13.3333 & \ding{55} \\
1 - 2 - 0 & 3 & 17.3333 & \ding{51} \\
1 - 2 - 1 & 4 & 9.3333 & \ding{55} \\
1 - 3 - 0 & 4 & 13.3333 & \ding{55} \\
1 - 3 - 1 & 5 & 5.3333 & \ding{55} \\
1 - 4 - 0 & 5 & 9.3333 & \ding{55} \\
1 - 4 - 1 & 6 & 1.3333 & \ding{55} \\
\bottomrule
\end{tabular}
\caption{Combinaciones posibles fuerza bruta}
\end{table}
\end{center}



\textbf{¿Por qué el algoritmo eligió la de mayor esfuerzo si el conflicto era igual?}

\textbf{Inferencia:} El algoritmo busca la \textit{primera combinación} con el menor conflicto.

\begin{itemize}
    \item \textbf{Paso 1:} Recorre las combinaciones en orden (como las va generando).
    \item \textbf{Paso 2:} Guarda la primera que cumpla con:
    \begin{itemize}
        \item Esfuerzo $\leq R_{\text{max}}$
        \item Menor conflicto interno encontrado hasta el momento.
    \end{itemize}
\end{itemize}

\vspace{0.5em}

\textbf{Resolución:}
\begin{itemize}
    \item Encuentra \texttt{1 - 0 - 1} con conflicto $21.33 \rightarrow$ lo guarda. \ding{72}
    \item Luego llega a \texttt{1 - 1 - 0} con mismo conflicto, pero como no mejora el conflicto, no actualiza aunque tenga menor esfuerzo.
\end{itemize}


\subsection*{Resultados Finales del Algoritmo}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|}
\hline
\rowcolor[HTML]{EFEFEF}
\textbf{Métrica} & \textbf{Valor} \\
\hline
Estrategia óptima & {[}1, 0, 1{]} \\
\hline
Conflicto interno & 213.333 \\
\hline
Esfuerzo total & 4 \\
\hline
Tiempo de ejecución & 0.0001 segundos \\
\hline
\end{tabular}
\caption{Resultados obtenidos: análisis fuerza bruta.}
\end{table}

Este ejemplo ilustra cómo el algoritmo de fuerza bruta explora exhaustivamente todas las posibles combinaciones de esfuerzos para encontrar la que minimice el conflicto interno. Aunque este enfoque garantiza encontrar la solución óptima, tiene una complejidad exponencial, ya que el número de combinaciones crece rápidamente con cada grupo o incremento de agentes.

En esta prueba con solo 3 grupos y 20 combinaciones, el tiempo de ejecución fue casi instantáneo, lo que demuestra que para problemas pequeños es muy efectivo. Sin embargo, en problemas reales con muchos grupos o agentes, este enfoque se vuelve inviable por el alto costo computacional, siendo recomendable en esos casos el uso de algoritmos voraces o programación dinámica.

\subsection{Impacto en el Rendimiento}
\label{sec:limitaciones_fuerza_bruta}

A pesar de su simplicidad, el enfoque de fuerza bruta presenta importantes limitaciones prácticas. Una de las más críticas es el impacto que tiene sobre el rendimiento a medida que crece el tamaño de la red social o el número de agentes por grupo.

Supongamos que la red social está compuesta por \( n \) grupos, y que cada grupo \( i \) tiene \( a_i \) agentes. Como las estrategias posibles para cada grupo van desde moderar 0 hasta \( a_i \) agentes, entonces el número de combinaciones de estrategias posibles es:

\[
\prod_{i=1}^{n} (a_i + 1)
\]

Este crecimiento es exponencial en el número de grupos, y además está influenciado por el tamaño de cada grupo. Incluso si cada grupo tuviera pocos agentes, al multiplicar las posibilidades de todos los grupos, el total de combinaciones puede escalar rápidamente.

Por ejemplo, para un conjunto de grupos con tamaños heterogéneos, como:

\[
\left\{ a_1, a_2, \ldots, a_n \right\}
\]

...el total de estrategias a evaluar será:

\[
(a_1 + 1) \cdot (a_2 + 1) \cdot \ldots \cdot (a_n + 1)
\]
Cada una de estas combinaciones debe ser evaluada para calcular su conflicto interno y su esfuerzo total, lo que implica un costo computacional adicional por iteración.
\vspace{1em}
\noindent
\begin{tcolorbox}[colback=red!5!white, colframe=red!50!black, title=Advertencia sobre rendimiento]
 Aunque el algoritmo garantiza encontrar la solución óptima, el tiempo de ejecución crece de forma multiplicativa con la cantidad de grupos y el tamaño de cada uno, lo que puede llevar a tiempos de ejecución inaceptables en redes sociales grandes.

En estos casos, se vuelve recomendable recurrir a algoritmos de programación dinámica, que también garantiza la solución óptima en menor tiempo o voraces que sacrifican algo de precisión a cambio de un rendimiento mucho más eficiente.
\end{tcolorbox}



%%%%%%% FUERZA BRUTA %%%%%%% FIN
\newpage

%%%%%%% ALGORITMO DINÁMICO %%%%%%% INICIO
\section{Algoritmo Dinámico}
\subsection{Descripción}

El algoritmo de programación dinámica aplicado en este proyecto busca minimizar el conflicto interno dentro de una red social, bajo la restricción de un presupuesto limitado de esfuerzo (denotado como $R_{\text{max}}$). Este conflicto surge de las diferencias de opinión entre los agentes de distintos grupos, y puede ser mitigado parcialmente moderando a algunos de estos agentes, a costa de cierto esfuerzo.

A diferencia de enfoques exhaustivos como la fuerza bruta, que evalúan todas las combinaciones posibles de moderación, este algoritmo divide el problema en subproblemas más pequeños y los resuelve de manera progresiva y óptima, reutilizando resultados previamente calculados para construir la solución global.

El proceso se fundamenta en el principio de \textit{optimalidad de Bellman}, que asegura que una solución óptima para el problema completo puede ser construida a partir de soluciones óptimas de sus subproblemas.

A cada paso, el algoritmo evalúa todas las opciones posibles de moderación para un grupo específico —desde no moderar a ningún agente hasta moderar a todos— y calcula el conflicto y esfuerzo que implicaría esa decisión. Luego, actualiza de forma eficiente una estructura de datos que almacena, para cada cantidad de esfuerzo acumulado, la mejor configuración encontrada hasta ese punto.

Al finalizar, se selecciona la estrategia que, sin superar el esfuerzo disponible, logra el menor conflicto interno posible.

Este enfoque garantiza que la solución obtenida es óptima dentro de las restricciones definidas, y resulta mucho más escalable que evaluar explícitamente todas las combinaciones posibles, especialmente en redes sociales con un número elevado de grupos o agentes.

\subsection{Pasos Programación Dinámica}
Sabemos que para calcular la solución óptima para un algoritmo dinámico se deben 
cumplir ciertos aspectos:
\begin{enumerate}
    \item Caracterizar la solución óptima (Subestructura óptima) 
    \item Definir recursivamente el valor de la solución óptima
    \item Calcular el valor de la solución óptima (algoritmo) 
    \item Construir la solución óptima (algoritmo)
\end{enumerate}

\subsubsection{Caracterizando la Estructura de una Solución Óptima}

Para resolver el problema de minimizar el conflicto interno en una red social bajo una restricción de esfuerzo máximo permitido ($R_{\text{max}}$), es necesario comprender cómo se construye la solución óptima a partir de decisiones locales en cada grupo de agentes.

\begin{itemize}
    \item \textbf{Definición del problema original:}
    
    Denotamos el problema general como:
    \[
        \text{MinCI}(Grupos_n, R_{\text{max}})
    \]
    donde:
    \begin{itemize}
        \item $Grupos_n$: conjunto de $n$ grupos sociales.
        \item $R_{\text{max}}$: esfuerzo total máximo permitido.
        \item $\text{MinCI}$: equivale a la función objetivo del problema, que llamamos \texttt{ModCI}.
    \end{itemize}
    
    \item \textbf{Subproblemas:}
    
    El enfoque de programación dinámica divide el problema en subproblemas de la forma:
    \[
        \text{MinCI}(Grupos_i, R_j)
    \]
    donde:
    \begin{itemize}
        \item $i$ representa los primeros $i$ grupos, con $1 \leq i \leq n$
        \item $R_j$ representa el esfuerzo disponible en ese momento, con $0 \leq j \leq R_{\text{max}}$
    \end{itemize}
    
    \item \textbf{Recurrencia y decisiones:}
    
    Para cada grupo $i$, se evalúan todas las decisiones posibles de moderación: desde moderar a $0$ hasta moderar a $n_i$ agentes (cantidad total del grupo). A cada opción le corresponde un coste de esfuerzo $e$ y un conflicto potencial.
    
    La decisión óptima para el subproblema $\text{MinCI}(Grupos_i, R_j)$ se construye a partir de:
    \begin{itemize}
        \item Las decisiones óptimas de los subproblemas anteriores ($i - 1$).
        \item Comparando todas las combinaciones posibles de moderación:
        \[
            e \in [0, n_i]
        \]
        \item Solo se consideran las combinaciones que cumplen:
        \[
            Costo(e) \leq R_j
        \]
    \end{itemize}
    
    Para cada combinación válida, se calcula:
    \[
        CI_{\text{acumulado}} = CI_{\text{previo}} + (n_i - e)(o_{1i} - o_{2i})^2
    \]
    
    donde:
    \begin{itemize}
        \item $CI_{\text{acumulado}}$: conflicto total acumulado hasta el grupo actual $i$, considerando la estrategia de esfuerzo aplicada.
        \item $CI_{\text{previo}}$: conflicto acumulado hasta el grupo $i - 1$, correspondiente a una asignación de esfuerzo previa.
        \item $n_i$: número total de agentes en el grupo $i$.
        \item $e$: número de agentes moderados en el grupo $i$.
        \item $n_i - e$: número de agentes no moderados en el grupo $i$.
        \item $(o_{1i} - o_{2i})$: diferencia cuadrática entre las dos opiniones del grupo. Refleja la intensidad del conflicto si no se modera ese grupo.
    \end{itemize}
    
    \item \textbf{Estructura óptima:}
    
    Así, la solución óptima para el problema completo:
    \[
        \text{MinCI}(Grupos_n, R_{\text{max}})
    \]
    se obtiene reutilizando las mejores soluciones de los subproblemas previos, considerando todas las configuraciones posibles de esfuerzo y moderación por grupo.
\end{itemize}

Esto permite:
\begin{itemize}
    \item Mantener un historial de las mejores decisiones hasta cada punto.
    \item Evitar recalcular combinaciones ya exploradas.
    \item Garantizar una solución óptima dentro del límite de esfuerzo.
\end{itemize}

\subsubsection{Definiendo Recursivamente el Valor de la Solución Óptima}

Una vez caracterizada la subestructura óptima, necesitamos definir una fórmula recursiva que describa cómo se calcula el valor de la solución óptima a partir de los subproblemas.

\begin{itemize}
    \item \textbf{Variables:}
    \begin{itemize}
        \item $i$: índice del grupo actual ($0$-indexado)
        \item $e$: número de agentes moderados en el grupo $i$ ($0 \leq e \leq n_i$)
        \item $c(i, e)$: esfuerzo necesario para moderar $e$ agentes en el grupo $i$
        \item $(o_{1i}, o_{2i})$: distancia cuadrática de opiniones en el grupo $i$
        \item $S(i, j)$: valor mínimo del conflicto interno al considerar los primeros $i$ grupos con un total de esfuerzo $j$
    \end{itemize}

    \item \textbf{Recurrencia:}
    \[
    S(i, j) = \min_{0 \leq e \leq n_i,\, c(i,e) \leq j} \left\{ S(i - 1, j - c(i, e)) + (n_i - e) \cdot d_i \right\}
    \]

    \item \textbf{Explicación:}
    \begin{itemize}
        \item Para cada grupo $i$, evaluamos todas las posibles cantidades de agentes $e$ que podrían moderarse.
        \item El costo en esfuerzo por moderar $e$ agentes se calcula como:
        \[
            c(i, e) = \lceil |o_{1i} - o_{2i}| \cdot rigidez_i \cdot e \rceil
        \]
        \item Si ese esfuerzo no supera el total disponible $j$, entonces actualizamos el conflicto acumulado:
        \begin{itemize}
            \item Se agrega el impacto de los $n_i - e$ agentes no moderados, que contribuyen al conflicto interno con el factor $d_i$.
        \end{itemize}
        \item De todas las combinaciones viables, nos quedamos con la que minimice el conflicto total.
    \end{itemize}

    \item \textbf{Condiciones triviales:}
    \[
    S(-1, 0) = 0
    \]
    \[
    S(-1, j) = \infty, \quad \text{si } j > 0
    \]

    Esto indica que al inicio, sin haber procesado ningún grupo, solo se puede tener un conflicto acumulado 0 si no se ha usado esfuerzo. Todo lo demás es inválido.

    \subsubsection{Calculando el Valor de la Solución Óptima}
    La construcción de la solución óptima se fundamenta en el almacenamiento y la actualización de la lista de decisiones (\textbf{decisions}). Cada vez que se actualiza el estado en $dp[i+1]$, se guarda la decisión tomada para el grupo $i$. Al finalizar el proceso, la función \textbf{seleccionar\_mejor\_estrategia} recorre los estados finales y recupera la secuencia de decisiones que produjo el menor conflicto, dando como resultado la reconstrucción de la solución óptima.
    \subsubsection{Construyendo la Solución Óptima}
    \subsubsection{¿Cuántos Subproblemas Hay?}
    El número de subproblemas esta ligado a:
    \begin{itemize}
    \item La cantidad de grupos $(n+1)$
    \item Los esfuerzos utilizados los cuales estan en el rango de $[0, R_{max}]$ el cual se representa como $R_{max}+1$
    \item El número total de agentes restantes hasta el momento el cual esta determinado por \textbf{total\_rem} ($K+1$)
\end{itemize}
Por ende el total de subproblemas será: 
    \[
        (n+1)\cdot(R_{max}+1)\cdot(K+1)
    \]
K es considerado ya que refleja mejor la cantidad de estados realmente guardados, no sólo el rango de posibles valores el cual implica considerar todos los agentes de la red social.

    \subsection{Implementación}
    La implemenctación de \textbf{modciPD.py} sigue los siguientes pasos:
    \begin{enumerate}
     
    \item \textbf{Inicialización de DP:}
    \begin{itemize}
        \item Se crea la tabla $dp$ como una lista de diccionarios, la cual será la encargada de guardar los pasos que lleven a la solución óptima.
        
    \end{itemize}
    
    \item \textbf{Actualización de estados:}
    \begin{itemize}
        \item Para cada grupo dentro de la red, se recorren las posibles decisiones (pasos) y estas son almacenadas solo si cumplen con el criterio de que al aplicar las mismas no se puede superar el esfuerzo máximo proporcionado por la red. 
    \end{itemize}
    
    \item \textbf{Selección de la estrategia óptima:}
     \begin{itemize}
        \item Una vez procesados todos los grupos, la función \textbf{seleccionar\_mejor\_estrategia} recorre las soluciones guardadas y selecciona la que tenga un menor conflicto interno, finalmente la función reconstruye los pasos que llevaron a dicha solución, el valor del conflicto de la misma y el esfuerzo necesario para aplicarla.
    \end{itemize}
    
    \item \textbf{Calculo final:}
     \begin{itemize}
        \item Finalmente, la función \textbf{calcular\_ci\_esfuerzo } se  encarga de calcular el conflicto final y se retorna la solución óptima. 
    \end{itemize}
\end{enumerate}

    \subsection{Pseudocódigo}
    \begin{algorithm}[H]
    \caption{modciPD: Estrategia óptima con programación dinámica}
    \KwIn{Una red social $RS$ como lista de tuplas $(n_i, op1_i, op2_i, rigidez_i)$ para cada grupo $i$, y un esfuerzo máximo permitido $R_{max}$}
    \KwOut{Tupla $(CI_{\min}, Esfuerzo_{\text{total}}, Estrategia_{\text{óptima}})$}
    
    $n \leftarrow$ cantidades por grupo, $op1$, $op2$, $rigidez$ extraídos de $RS$ \\
    $d_i \leftarrow (op1_i - op2_i)^2$ para cada grupo $i$ \tcp*[r]{Desacuerdo cuadrático}
    
    Inicializar $dp[0][0][0] \leftarrow (0.0, [])$ \tcp*[r]{Suma $S$, decisiones}
    
    \For{$i \leftarrow 0$ \KwTo $|RS| - 1$}{
        \ForEach{$usedEffort$ en $dp[i]$}{
            \ForEach{$rem, (S, decisions)$ en $dp[i][usedEffort]$}{
                \For{$e \leftarrow 0$ \KwTo $n_i$}{
                    $cost \leftarrow \lceil |op1_i - op2_i| \cdot rigidez_i \cdot e \rceil$ \\
                    $newEffort \leftarrow usedEffort + cost$ \\
                    \If{$newEffort \leq R_{max}$}{
                        $newRem \leftarrow n_i - e$ \\
                        $newTotal \leftarrow rem + newRem$ \\
                        $newS \leftarrow S + newRem \cdot d_i$ \\
                        $newDecisions \leftarrow decisions + [e]$ \\
                        \If{$newEffort$ no está en $dp[i+1]$}{
                            Crear $dp[i+1][newEffort] \leftarrow \{\}$
                        }
                        \If{$newTotal$ no está en $dp[i+1][newEffort]$ \textbf{or} $newS < dp[i+1][newEffort][newTotal].S$}{
                            $dp[i+1][newEffort][newTotal] \leftarrow (newS, newDecisions)$
                        }
                    }
                }
            }
        }
    }
    
    $mejorCI \leftarrow \infty$, $mejorEstrategia \leftarrow$ \texttt{None} \\
    \ForEach{$usedEffort$ en $dp[num\_grupos]$}{
        \ForEach{$totalRem, (S, decisions)$ en $dp[num\_grupos][usedEffort]$}{
            $conflict \leftarrow S / num\_grupos$ \\
            \If{$conflict < mejorCI$}{
                $mejorCI \leftarrow conflict$ \\
                $mejorEstrategia \leftarrow decisions$
            }
        }
    }
    
    \If{$mejorEstrategia = \texttt{None}$}{
        \Return $(\infty, 0, [])$
    }
    \Else{
        \Return calcular\_ci\_esfuerzo($RS$, $mejorEstrategia$) $+ (mejorEstrategia)$
    }
    \end{algorithm}

    \subsection{Complejidad}
    \subsubsection{Complejidad Temporal}
    
    Las operaciones que principalmente realiza \textbf{modciPD} y que serán de ayuda para entender su complejidad temporal serán:

    \begin{itemize}
        \item actualizar\_dp: $O(n[i])$ el recorrido que esta hace en su bucle interno depende de $n[i]$.
        
        \item seleccionar\_mejor\_estrategia: $O(R_{max})$ el recorrido que esta hace en su bucle interno depende de $R_{max}$ 
    \end{itemize}

    Finalmente dado a que estas son llamadas dentro de la función dentro de un bucle el cual depende de $n$ la complejidad final estará dada por:
    $$O(n\times n[i] \times R_{max})$$
    
    \subsubsection{Complejidad Espacial}
    La complejidad espacial viene dada por el número de estados almacenados en la tabla $dp$. En el peor caso, se pueden almacenar estados para cada combinación de:

    \begin{itemize}
        \item Grupos $(n)$.
        \item Esfuerzo acumulado (hasta $R_{max}$).
        \item Valores de total\_rem $K$ 
    \end{itemize}

    Esto implica una complejidad espacial del orden de:

    \[
        O(n \times R_{max} \times K)
    \]

    Donde $K$ es el factor derivado de los posibles valores para total\_rem. No obstante, la implementación optimiza este almacenamiento guardando únicamente estados que minimizan el conflicto.
    
    \subsubsection{¿Es Útil en la Práctica}
    El enfoque de programación dinámica es útil para reducir drásticamente el número de combinaciones evaluadas en comparación con una busqueda exhaustiva, especialmente en instancias donde el número de grupos $n$ y el esfuerzo máximo $R_{max}$ son moderados.
    
    \paragraph{Hipótesis:}

    La reutilización de resultados parciales mediante $DP$ permite calcular la solución óptima sin tener que explorar todo el campo de de las posibles estrategias que se puedan aplicar. 
    
    \paragraph{Conclusión Hipótesis Temporal:}
    
    Cuando el número de grupos y el límite $R_{max}$ no son excesivamente altos, el $DP$ consigue una solución óptima en un tiempo razonable. Sin embargo, para parámetros muy grandes, la cantidad de estados podría crecer y afectar el tiempo de ejecución, aunque sigue siendo una mejora significativa a comparación de un algoritmo de fuerza bruta.
    
    \paragraph{Conclusión Hipótesis Espacial:}
    
    El uso de memoria adicional para almacenar la tabla $dp$ es el que mayor impacto tiene en cuanto al costo espacial del método. Aún así, en la práctica la poda de estados ineficientes y la restricción basada en el esfuerzo máximo $(R_{max})$ reducen considerablemente la cantidad de memoria requerida, haciendolo viable para redes con un tamaño significativamente grande.
    
    \subsection{¿El Algoritmo Siempre da la Respuesta Correcta al Problema?}
    
    Sí. Al basarse en programación dinámica, este método garantiza la obtención de la solución óptima para el problema de moderar el conflicto interno en una red social, siempre que se cumplan las siguientes condiciones:
    
    \begin{itemize}
    
      \item \textbf{Propiedad de subestructura óptima:} 
      El problema puede descomponerse en subproblemas cuya solución óptima se construye a partir de las soluciones óptimas de instancias más pequeñas. Cada decisión de moderar un grupo de agentes se basa en resultados parciales previamente calculados, de modo que ninguna combinación viable queda fuera del análisis.
    
      \item \textbf{Cobertura exhaustiva de las estrategias viables:} 
      Se consideran, para cada grupo, todas las cantidades posibles de agentes a moderar (desde cero hasta el tamaño del grupo), respetando siempre el límite de esfuerzo disponible. Esto asegura que no se descarte ninguna estrategia factible que pudiera conducir al mínimo conflicto.
    
      \item \textbf{Comparación y selección global:} 
      Una vez evaluadas todas las combinaciones válidas, se selecciona aquella cuyo nivel de conflicto interno final es el más bajo. Al procesar sistemáticamente todos los subproblemas y reconstruir la mejor secuencia de moderación, la solución resultante es, por definición, la óptima.
    
    \end{itemize}
    
    \paragraph{Limitaciones prácticas:}
    
    En teoría, la corrección está garantizada mientras se exploren y almacenen todas las combinaciones de subproblemas. En la práctica, a medida que crecen el número de grupos y el presupuesto de esfuerzo, la cantidad de estados intermedios puede aumentar y exigir grandes recursos de memoria o tiempo. No obstante, en instancias de tamaño moderado, estas exigencias siguen siendo manejables y la estrategia conserva su garantía de optimalidad.
    
    \subsection{Análisis}

    El método de programación dinámica, aplicado al problema de moderación de opiniones, presenta las siguientes características de comportamiento:

        \begin{itemize}
    
    \item \textbf{Crecimiento polinómico controlado:}  
    El tiempo de cómputo crece de forma suave al aumentar el número de grupos, manteniéndose dentro de una escala práctica (desde milisegundos hasta minutos). Esto refleja que, aunque se exploran múltiples estados, la fusión de soluciones parciales evita la explosión exponencial.


    \item \textbf{Estabilidad frente a variaciones de presupuesto:} 
    Para un mismo tamaño de red, la variación del límite de esfuerzo provoca oscilaciones en el tiempo (mayor esfuerzo → más estados a evaluar), pero nunca aumenta desproporcionadamente. Esto evidencia que la estructura de DP maneja eficientemente incluso presupuestos altos.

    \item \textbf{Escalabilidad hasta instancias moderadas–grandes:} 
        
        \begin{itemize}
        
          \item \textbf{Pequeñas ($n \leq 10$):}  
          tiempos imperceptibles ($<$ 1~ms–500~ms).
        
          \item \textbf{Medianas ($10 < n \leq 25$):} 
          siempre por debajo de 13~s, adecuado para uso interactivo.
        
          \item \textbf{Grandes ($25 < n \leq 50$):} 
          de decenas a centenares de segundos, aceptable en procesos batch o análisis offline.
        
          \item \textbf{Muy grandes ($n \approx 100$):} 
          alrededor de 5~min, puede considerarse límite práctico sin optimizaciones adicionales.
        
        \end{itemize}

    
    \item \textbf{Equilibrio espacio-tiempo:}  
    El algoritmo sacrifica algo de memoria para almacenar la tabla de estados, pero a cambio evita recomputaciones y ofrece un rendimiento más predecible frente a heurísticos voraces o fuerza bruta.
    
    \end{itemize}
    
    \subsection{Impacto en El Rendimiento}
    A continuación, los tiempos observados en diversas pruebas con presupuestos variados, medidos en segundos:

        \begin{table}[h!]
    \centering
    \begin{tabular}{|c|c|c|}
    \hline
    \textbf{Grupos} & \textbf{Mínimo (s)} & \textbf{Máximo (s)} \\
    \hline
    5   & 0{,}0021 & 0{,}0073 \\
    10  & 0{,}0029 & 0{,}5037 \\
    15  & 0{,}0402 & 5{,}1563 \\
    20  & 3{,}3455 & 8{,}9823 \\
    25  & 5{,}4816 & 12{,}4681 \\
    50  & 29{,}3461 & 174{,}4527 \\
    100 & ---      & 296{,}0398 \\
    \hline
    \end{tabular}
    \caption{Tiempos de ejecución mínimo y máximo por número de grupos}
    \label{tab:tiempos-grupos}
        \end{table}


    \begin{itemize}
    
         \item \textbf{Umbral interactivo:} 
        hasta 15 grupos se mantiene por debajo de 5 s incluso en el peor caso.

        \item \textbf{Procesamiento batch:} 
        entre 20 y 50 grupos, cabe en un marco de decenas de segundos a pocos minutos.

        \item \textbf{Límite práctico:} 
         alrededor de 100 grupos, el tiempo se acerca a los 5 min, recomendando optimizaciones o partición de la red si se precisa mayor escala.
    
    \end{itemize}


\end{itemize}

%%%%%%% ALGORITMO DINÁMICO %%%%%%% FIN

\newpage


    \section{Algoritmo Voraz}

    \subsection{Descripción}
    El algoritmo voraz implementado aborda el problema de minimizar el conflicto interno dentro de una red social, sujeto a una restricción presupuestal de esfuerzo (denotada como $R_{max}$). El conflicto surge a partir de las discrepancias entre las opiniones que los agentes expresan sobre dos afirmaciones, y puede ser reducido moderando a ciertos agentes, aunque dicha acción implica un costo en términos de esfuerzo.

    A diferencia del enfoque de fuerza bruta, que explora exhaustivamente todas las combinaciones posibles de moderación, y del enfoque de programación dinámica, que construye soluciones óptimas a partir de subproblemas más pequeños, este enfoque se basa en una estrategia de decisión secuencial que busca aprovechar el esfuerzo disponible de la forma más eficiente posible. Para ello, cada grupo de agentes es evaluado según un criterio heurístico que estima la utilidad relativa de intervenir sobre él.

    Este enfoque no garantiza encontrar la solución óptima al problema, ya que no explora todo el espacio de posibilidades. Sin embargo, en muchos casos ofrece soluciones de buena calidad con un costo computacional mucho menor, lo que lo convierte en una opción atractiva para redes sociales de mayor tamaño o para situaciones donde el tiempo de cómputo es limitado.

    \subsection{Definición de la heurística}

    La toma de decisiones del algoritmo voraz se fundamenta en una heurística que asigna una utilidad a cada grupo de agentes, con el propósito de priorizar aquellos cuya moderación podría ser más efectiva en términos de reducción del conflicto interno por unidad de esfuerzo.

    La utilidad asignada a cada grupo se define como:

    \[
        \text{utilidad}_i = \frac{|op1_i - op2_i|}{\max(rigidez_i, \varepsilon)}
    \]

    donde:
    \begin{itemize}
        \item $op1_i$ y $op2_i$ son las opiniones del grupo $i$ frente a las dos afirmaciones del problema,
        \item $rigidez_i$ es el nivel de resistencia al cambio de opinión del grupo $i$,
        \item $\varepsilon$ es una constante positiva muy pequeña que evita divisiones por cero.
    \end{itemize}

    Esta función favorece a los grupos que presentan una alta discrepancia de opiniones y baja rigidez, es decir, aquellos en los que intervenir podría tener mayor impacto y menor costo relativo.

    Una vez calculadas las utilidades para todos los grupos, se ordenan en orden descendente y se asigna el esfuerzo disponible comenzando por los grupos más rentables, hasta agotar el presupuesto permitido $R_{max}$ o no poder realizar más asignaciones viables.

\subsection{¿Entendimos el Algoritmo?}
\subsubsection{Solución del Ejercicio 2.3.1}

Consideramos la red social $\mathcal{RS}_1 = ( \langle 3, -100, 50, 0.5 \rangle, \langle 1, 100, 80, 0.1 \rangle, \langle 1, -10, 0, 0.5 \rangle, R_{max} = 80 )$, compuesta por tres grupos de agentes. La información detallada de los grupos es la siguiente:

\begin{table}[H]
\centering
\begin{tabular}{c|c|c|c|c}
\textbf{Grupo} & $n_i$ (agentes) & $o_{i1}$ & $o_{i2}$ & $r_i $ (rigidez) \\
\hline
0 & 3 & -100 & 50 & 0.5 \\
1 & 1 & 100 & 80 & 0.1 \\
2 & 1 & -10 & 0 & 0.5 \\
\end{tabular}
\caption{Datos de entrada de la red social $\mathcal{RS}_1$}
\end{table}

\subsubsection*{Paso 1: Cálculo de utilidad y costo unitario}

Calculamos para cada grupo su utilidad según la \nameref{sec:Definición de la Heurística}) y el costo de moderar a un solo agente:

\begin{table}[H]
\centering
\begin{tabular}{c|c|c}
\textbf{Grupo} & Utilidad heurística & Costo unitario por agente \\
\hline
0 & $\frac{|-100 - 50|}{0.5} = 300$ & $\lceil 150 \cdot 0.5 \rceil = 75$ \\
1 & $\frac{|100 - 80|}{0.1} = 200$ & $\lceil 20 \cdot 0.1 \rceil = 2$ \\
2 & $\frac{|-10 - 0|}{0.5} = 20$ & $\lceil 10 \cdot 0.5 \rceil = 5$ \\
\end{tabular}
\caption{Utilidades y costos unitarios de la red social $\mathcal{RS}_1$}
\end{table}

\subsubsection*{Paso 2: Orden de prioridad por utilidad}

Ordenamos los grupos en orden descendente según su utilidad:

\begin{enumerate}
    \item Grupo 0: utilidad 300
    \item Grupo 1: utilidad 200
    \item Grupo 2: utilidad 20
\end{enumerate}

\subsubsection*{Paso 3: Asignación de esfuerzo}

Inicializamos $R_{\text{max}} = 80$.

\begin{itemize}
    \item \textbf{Grupo 0}:
        \begin{itemize}
            \item Costo unitario: 75
            \item Máximo posible: $\left\lfloor \frac{80}{75} \right\rfloor = 1$ agente
            \item Se asigna: 1 agente
            \item Nuevo $R_{\text{max}} = 80 - 75 = 5$
        \end{itemize}

    \item \textbf{Grupo 1}:
        \begin{itemize}
            \item Costo unitario: 2
            \item Máximo posible: $\left\lfloor \frac{5}{2} \right\rfloor = 2$, pero el grupo tiene solo 1 agente
            \item Se asigna: 1 agente
            \item Nuevo $R_{\text{max}} = 5 - 2 = 3$
        \end{itemize}

    \item \textbf{Grupo 2}:
        \begin{itemize}
            \item Costo unitario: 5
            \item Máximo posible: $\left\lfloor \frac{3}{5} \right\rfloor = 0$
            \item No se asignan agentes
        \end{itemize}
\end{itemize}

\subsubsection*{Resultado parcial de la estrategia}

\begin{itemize}
    \item \textbf{Estrategia aplicada ($E_V$): } $[1, 1, 0]$
    \item \textbf{Esfuerzo total utilizado:} $75 + 2 = 77$
\end{itemize}

\subsubsection*{Cálculo del conflicto interno}

La siguiente tabla muestra, grupo por grupo, cómo se calcula el conflicto interno de la red tras aplicar la estrategia $E_V = [1, 1, 0]$:

\begin{table}[H]
\centering
\begin{tabular}{c|c|c|c|c|c}
\textbf{Grupo} & $n_i$ & $e_i$ & $n_i - e_i$ (no moderados) & $(o_{i1} - o_{i2})^2$ & Aporte al CI \\
\hline
0 & 3 & 1 & 2 & $(-100 - 50)^2 = 22500$ & $2 \cdot 22500 = 45000$ \\
1 & 1 & 1 & 0 & $(100 - 80)^2 = 400$ & $0 \cdot 400 = 0$ \\
2 & 1 & 0 & 1 & $(-10 - 0)^2 = 100$ & $1 \cdot 100 = 100$ \\
\hline
\multicolumn{5}{r|}{\textbf{Suma total}} & 45100 \\
\end{tabular}
\caption{Cálculo del conflicto interno con la estrategia $E_V$ para $\mathcal{RS}_1$}
\end{table}

\textbf{Conflicto interno resultante:} $\frac{45100}{3} \approx 15033.33$

\subsubsection*{Resultado final}

\begin{itemize}
    \item \textbf{Estrategia aplicada:} $[1, 1, 0]$
    \item \textbf{Esfuerzo total utilizado:} $77$
    \item \textbf{Conflicto interno resultante:} $\approx 15033.33$
\end{itemize}

\subsubsection*{Análisis final y respuestas a las preguntas del ejercicio}

Para la red social $\mathcal{RS}_1$ se compararon tres estrategias:

\begin{itemize}
    \item \textbf{Estrategia $E_1$}: $[0, 1, 1]$, con esfuerzo total $7$ y conflicto interno $22500$
    \item \textbf{Estrategia $E_2$}: $[1, 0, 0]$, con esfuerzo total $75$ y conflicto interno $15166.66$
    \item \textbf{Estrategia $E_V$}: $[1, 1, 0]$, con esfuerzo total $77$ y conflicto interno $\approx 15033.33$
\end{itemize}

A partir de estos resultados, respondemos las preguntas planteadas:

\begin{itemize}
    \item \textbf{¿Habrá mejores soluciones que $E_2$?} \\
    Sí. La estrategia $E_V$ encontrada por el algoritmo voraz logra un menor nivel de conflicto interno ($\approx 15033.33$) que $E_2$ ($15166.66$), y sigue siendo aplicable dentro del esfuerzo permitido ($77 \leq 80$). Además, esta estrategia fue verificada con el enfoque de fuerza bruta, confirmando que es la solución óptima para esta instancia.

    \item \textbf{¿Habrá estrategias de moderación no aplicables?} \\
    Sí. Por ejemplo, la estrategia $[2, 1, 1]$ (es decir, moderar a 2 agentes del grupo 0, 1 del grupo 1 y 1 del grupo 2) resulta en un esfuerzo total de:
    \[
    \lceil 150 \cdot 0.5 \cdot 2 \rceil + \lceil 20 \cdot 0.1 \cdot 1 \rceil + \lceil 10 \cdot 0.5 \cdot 1 \rceil = 150 + 2 + 5 = 157
    \]
    lo cual excede el límite $R_{max} = 80$. Por tanto, no es aplicable.

\end{itemize}



\subsubsection{Solución del Ejercicio 2.3.2}

Consideramos la red social $RS2 = ( \langle 3, -100, 100, 0.8 \rangle, \langle 2, 100, 80, 0.5 \rangle, \langle 4, -10, 10, 0.5 \rangle, R_{max} = 400 )$, compuesta por tres grupos de agentes. La información detallada de los grupos es la siguiente:

\begin{table}[H]
\centering
\begin{tabular}{c|c|c|c|c}
\textbf{Grupo} & $n_i$ (agentes) & $o_{i1}$ & $op_{i2}$ & $r_i$ (rigidez) \\
\hline
0 & 3 & -100 & 100 & 0.8 \\
1 & 2 & 100 & 80 & 0.5 \\
2 & 4 & -10 & 10 & 0.5 \\
\end{tabular}
\caption{Datos de entrada de la red social $\mathcal{RS}_2$}
\end{table}

\subsubsection*{Paso 1: Cálculo de utilidad y costo unitario}

Calculamos para cada grupo su utilidad según la \nameref{sec:Definición de la Heurística}) y el costo de moderar a un solo agente:

\begin{table}[H]
\centering
\begin{tabular}{c|c|c}
\textbf{Grupo} & Utilidad heurística & Costo unitario por agente \\
\hline
0 & $\frac{|-100 - 100|}{0.8} = 250$ & $\lceil 200 \cdot 0.8 \rceil = 160$ \\
1 & $\frac{|100 - 80|}{0.5} = 40$ & $\lceil 20 \cdot 0.5 \rceil = 10$ \\
2 & $\frac{|-10 - 10|}{0.5} = 40$ & $\lceil 20 \cdot 0.5 \rceil = 10$ \\
\end{tabular}
\caption{Utilidades y costos unitarios de la red social $\mathcal{RS}_2$}
\end{table}

\subsubsection*{Paso 2: Orden de prioridad por utilidad}

Ordenamos los grupos en orden descendente según su utilidad:

\begin{enumerate}
    \item Grupo 0: utilidad 250
    \item Grupo 1: utilidad 40
    \item Grupo 2: utilidad 40
\end{enumerate}

\subsubsection*{Paso 3: Asignación de esfuerzo}

Inicializamos $R_{\text{max}} = 400$.

\begin{itemize}
    \item \textbf{Grupo 0}:
        \begin{itemize}
            \item Costo unitario: 160
            \item Máximo posible: $\left\lfloor \frac{400}{160} \right\rfloor = 2$, pero el grupo tiene solo 3 agentes
            \item Se asigna: 2 agentes
            \item Nuevo $R_{\text{max}} = 400 - 2 \cdot 160 = 80$
        \end{itemize}

    \item \textbf{Grupo 1}:
        \begin{itemize}
            \item Costo unitario: 10
            \item Máximo posible: $\left\lfloor \frac{80}{10} \right\rfloor = 8$, pero el grupo tiene solo 2 agentes
            \item Se asigna: 2 agentes
            \item Nuevo $R_{\text{max}} = 80 - 2 \cdot 10 = 60$
        \end{itemize}

    \item \textbf{Grupo 2}:
        \begin{itemize}
            \item Costo unitario: 10
            \item Máximo posible: $\left\lfloor \frac{60}{10} \right\rfloor = 6$, pero el grupo tiene solo 4 agentes
            \item Se asigna: 4 agentes
            \item Nuevo $R_{\text{max}} = 60 - 4 \cdot 10 = 20$
        \end{itemize}
\end{itemize}

\subsubsection*{Resultado parcial de la estrategia}

\begin{itemize}
    \item \textbf{Estrategia aplicada ($E_V$): } $[2, 2, 4]$
    \item \textbf{Esfuerzo total utilizado:} $2 \cdot 160 + 2 \cdot 10 + 4 \cdot 10 = 320 + 20 + 40 = 380$
\end{itemize}

\subsubsection*{Cálculo del conflicto interno}

La siguiente tabla muestra, grupo por grupo, cómo se calcula el conflicto interno de la red tras aplicar la estrategia $E = [2, 2, 4]$:

\begin{table}[H]
\centering
\begin{tabular}{c|c|c|c|c|c}
\textbf{Grupo} & $n_i$ & $e_i$ & $n_i - c_i$ (no moderados) & $(o1_i - o2_i)^2$ & Aporte al CI \\
\hline
0 & 3 & 2 & 1 & $( -100 - 100 )^2 = 40000$ & $1 \cdot 40000 = 40000$ \\
1 & 2 & 2 & 0 & $(100 - 80)^2 = 400$ & $0$ \\
2 & 4 & 4 & 0 & $(-10 - 10)^2 = 400$ & $0$ \\
\hline
\multicolumn{5}{r|}{\textbf{Suma total}} & 40000 \\
\end{tabular}
\caption{Cálculo del conflicto interno con la estrategia $E_V$ para $\mathcal{RS}_2$}
\end{table}

\textbf{Conflicto interno resultante:} $\frac{40000}{3} \approx 13333.33$

\subsubsection*{Resultado final}

\begin{itemize}
    \item \textbf{Estrategia aplicada:} $[2, 2, 4]$
    \item \textbf{Esfuerzo total utilizado:} $380$
    \item \textbf{Conflicto interno resultante:} $\approx 13333.33$
\end{itemize}

\subsubsection*{Análisis final y respuestas a las preguntas del ejercicio}

En este ejercicio se compararon tres estrategias de moderación aplicables a la red social $RS2$:

\begin{itemize}
    \item \textbf{Estrategia $E_1$}: $[0, 1, 2]$ con esfuerzo total $30$ y conflicto interno $40400$
    \item \textbf{Estrategia $E_2$}: $[2, 2, 2]$ con esfuerzo total $360$ y conflicto interno $13600$
    \item \textbf{Estrategia $E_{V}$}: $[2, 2, 4]$ con esfuerzo total $380$ y conflicto interno $\approx 13333.33$
\end{itemize}

A partir de esta comparación, respondemos a las preguntas planteadas:

\begin{itemize}
    \item \textbf{¿Habrá mejores soluciones que $E_2$?} \\
    Sí. La estrategia encontrada mediante el algoritmo voraz $E_V$ logra un conflicto interno menor ($\approx 13333.33$ frente a $13600$) y cumple con el límite de esfuerzo ($380 \leq 400$). Además, se verificó que esta estrategia también fue identificada por el algoritmo de fuerza bruta como la solución óptima, lo que confirma su calidad.

    \item \textbf{¿Habrá estrategias de moderación no aplicables?} \\
    Sí. Existen muchas estrategias que no son viables porque requieren más esfuerzo del disponible. Por ejemplo, la estrategia $[3, 2, 4]$, que intenta moderar completamente a todos los grupos:
    \[
    \lceil 200 \cdot 0.8 \cdot 3 \rceil + \lceil 20 \cdot 0.5 \cdot 2 \rceil + \lceil 20 \cdot 0.5 \cdot 4 \rceil = 480 + 20 + 40 = 540
    \]
    lo cual supera el presupuesto de $R_{max} = 400$, y por tanto no es aplicable.
\end{itemize}


    \subsection{Implementación}

    La implementación del algoritmo voraz se realizó empleando una representación estructurada de la red social como una lista de tuplas. Cada tupla representa un grupo de agentes e incluye cuatro elementos: la cantidad de individuos en el grupo, sus opiniones frente a dos afirmaciones específicas y su nivel de rigidez al cambio de opinión.

    El proceso se estructura en dos fases principales:

    \begin{enumerate}
        \item \textbf{Cálculo de Utilidades y Priorización:} Para cada grupo, se calcula una utilidad basada en una heurística que considera la diferencia entre sus opiniones y su rigidez al cambio. Esta utilidad refleja cuán conveniente sería moderar a un grupo determinado en términos de impacto por unidad de esfuerzo. Luego, todos los grupos son ordenados en orden descendente según esta utilidad.

        \item \textbf{Asignación Voraz de Esfuerzo:} Siguiendo el orden de prioridad determinado, se asigna a cada grupo la cantidad máxima posible de agentes a moderar, respetando el esfuerzo restante disponible. Esta asignación se realiza considerando el costo unitario de moderar un agente en cada grupo, el cual depende de su rigidez y diferencia de opiniones. El proceso continúa hasta agotar el presupuesto de esfuerzo $R_{max}$ o no poder realizar más asignaciones viables.
    \end{enumerate}

    Al finalizar, la función auxiliar \texttt{calcular\_ci\_esfuerzo} se utiliza para evaluar el conflicto interno y el esfuerzo total correspondiente a la estrategia construida. El resultado final es una tupla que contiene el conflicto interno resultante, el esfuerzo total utilizado y la estrategia voraz de asignación de esfuerzos.

    \subsection{Pseudocódigo}
    \begin{algorithm}[H]
        \caption{modciPV: Estrategia voraz basada en utilidad heurística}
        \KwIn{Una red social $RS$ como lista de tuplas $(n_i, op1_i, op2_i, rigidez_i)$ para cada grupo $i$, y un esfuerzo máximo permitido $R_{max}$}
        \KwOut{Tupla $(CI, Esfuerzo_{\text{total}}, Estrategia)$}

        $estrategia \leftarrow [0, 0, \ldots, 0]$ \tcp*[r]{Inicializar estrategia vacía de tamaño $|RS|$}
        $esfuerzoRestante \leftarrow R_{max}$

        $utilidades \leftarrow []$ \tcp*[r]{Lista de utilidades heurísticas}

        \ForEach{grupo $g_i$ en $RS$}{
            \If{$n_i = 0$}{\textbf{continue}}

            $utilidad \leftarrow utilidad\_base(op1_i, op2_i, rigidez_i)$ \\
            $costoUnitario \leftarrow \max(1, \lceil |op1_i - op2_i| \cdot rigidez_i \rceil)$ \\
            $utilidades.\text{append}((utilidad, i, costoUnitario))$
        }

        $utilidades \leftarrow$ ordenar\_descendente(utilidades, clave=utilidad)

        \ForEach{$(utilidad, i, costoUnitario)$ en $utilidades$}{
            \If{$esfuerzoRestante \leq 0$}{\textbf{break}}

            $maxAsignable \leftarrow \min(n_i, \lfloor \frac{esfuerzoRestante}{costoUnitario} \rfloor)$ \\
            $estrategia[i] \leftarrow maxAsignable$ \\
            $esfuerzoRestante \leftarrow esfuerzoRestante - maxAsignable \cdot costoUnitario$
        }

        $(CI, esfuerzoTotal) \leftarrow calcular\_ci\_esfuerzo(RS, estrategia)$

        \Return $(CI, esfuerzoTotal, estrategia)$
    \end{algorithm}

    \subsection{Complejidad}

    \subsubsection{Complejidad temporal}

    El algoritmo voraz \texttt{modciPV} realiza las siguientes operaciones principales:

    \begin{itemize}
        \item Recorre todos los grupos de la red social (de tamaño $n$) para calcular una utilidad heurística y el esfuerzo unitario por agente. Esto toma ${O}(n)$.
        \item Ordena la lista de grupos por utilidad en orden descendente, lo cual tiene una complejidad de ${O}(n \log n)$.
        \item Itera sobre la lista ordenada para asignar agentes a moderar mientras haya esfuerzo disponible. En el peor caso, esta operación es lineal: ${O}(n)$.
        \item Finalmente, calcula el conflicto interno total y el esfuerzo utilizado, operación que, puede tomar ${O}(n)$.
    \end{itemize}

    Por lo tanto, la complejidad temporal total está dominada por el ordenamiento de la lista de grupos, lo cual nos da una complejidad de:

    \[
            {O}(n \log n)
    \]

    \subsubsection{Complejidad espacial}

    Respecto al uso de memoria, el algoritmo:

    \begin{itemize}
        \item Almacena información de utilidad por grupo en una lista auxiliar de tamaño $n$.
        \item Genera una lista de estrategias de tamaño $n$ (uno por grupo).
    \end{itemize}

    No se utilizan estructuras de datos anidadas ni matrices adicionales, por lo que el uso de espacio crece linealmente con el número de grupos.

    La complejidad espacial del algoritmo es entonces:

    \[
            {O}(n)
    \]

    \subsection{Corrección}

    El algoritmo voraz implementado para el problema ModCI proporciona una estrategia de moderación factible dentro del límite de esfuerzo permitido. Para ello, calcula una utilidad heurística para cada grupo de la red social y, en función de este valor, prioriza la asignación de recursos a aquellos grupos que se consideran más "rentables" en términos de impacto por unidad de esfuerzo.

    En cada paso, el algoritmo garantiza que:
    \begin{itemize}
        \item El esfuerzo total asignado no excede el presupuesto disponible $R_{max}$.
        \item Las asignaciones de agentes a moderar respetan los límites de cada grupo.
        \item La estrategia final generada es válida y puede ser evaluada con la función de conflicto interno.
    \end{itemize}

    Desde el punto de vista funcional, el algoritmo es correcto, ya que produce soluciones viables que cumplen con las restricciones del problema. No obstante, al tratarse de una heurística, no explora todo el espacio de soluciones posibles, por lo que no garantiza la obtención de la solución óptima global.

    A pesar de esta limitación, el enfoque voraz resulta especialmente útil en contextos donde la eficiencia computacional es prioritaria. Gracias a su bajo costo computacional y a su capacidad para generar soluciones razonables en tiempos reducidos, se convierte en una alternativa práctica y escalable frente a enfoques más costosos como la fuerza bruta.

    Para evaluar la calidad de sus soluciones, se ejecutó la batería de pruebas comparando los resultados del algoritmo voraz con las soluciones óptimas obtenidas por fuerza bruta o programación dinámica. En cada caso, se calculó el valor relativo de la diferencia mediante la fórmula:

    \[
        \frac{CI_{\text{voraz}}}{CI_{\text{óptima}}} - 1
    \]
    \vspace{0.5cm}

    A partir de estas pruebas, se obtuvo un promedio de aproximadamente $0{,}0162$, lo cual indica que, en promedio, la solución voraz fue apenas un 1,62\% peor que la óptima. Este bajo margen de desviación sugiere que el algoritmo voraz, aunque no exacto, puede ser altamente competitivo para resolver instancias del problema de forma eficiente.


    Teniendo en cuenta las complejidades de los tres enfoques se tiene que el enfoque voraz ofrece una excelente relación entre eficiencia y calidad de solución, especialmente cuando se busca un equilibrio entre rendimiento y precisión en redes sociales de gran tamaño.

    \subsubsection{¿Cuándo da la Respuesta Correcta?}

    \subsubsection{¿Cuándo no da la Respuesta Correcta?}

    \subsection{Análisis}

%%%%%%% ALGORITMO VORAZ %%%%%%% FIN

    \newpage

%%%%%%% COMPARACIÓN ALGORITMOS %%%%%%% INICIO


    \section{Comparación de Algoritmos}

    Haremos una comparativa de los tres algoritmos con las pruebas que se nos han proporcionado. La idea es entender mejor cómo se comporta cada uno, qué tan eficiente es y qué tipo de resultado podemos esperar en distintos escenarios.

    \subsection{Solución Óptima}

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.8\textwidth]{resources/conflictos.png}
        \caption{Comparativa gráfica del conflicto interno generado por cada algoritmo.}
    \end{figure}

    Al evaluar la precisión de los algoritmos, se compararon sus resultados con el valor de la solución (CI) obtenido para cada prueba y la comparación con los resultados de cada algoritmo permite medir su exactitud.

    \begin{itemize}
        \item \textbf{Fuerza bruta:}
        \begin{itemize}
            \item Garantiza la solución óptima siempre que logra completarse. En todas las pruebas donde arrojó un resultado, este coincidió exactamente con el valor de la solución óptima esperada.
            \item Sin embargo, falló en 23 de las 30 pruebas, marcadas con "X", lo que indica que no logró encontrar una solución dentro del tiempo razonable (especialmente a partir de 10 o más grupos de agentes).
        \end{itemize}
        \begin{figure}[H]
            \centering
            \includegraphics[width=0.8\textwidth]{resources/conflicto1.jpeg}
            \caption{Gráfica del conflicto interno generado por fuerza bruta.}
        \end{figure}
        \item \textbf{Programación dinámica:}
        \begin{itemize}
            \item Siempre encontró la solución óptima, incluso en instancias donde la fuerza bruta no completó.
            \item Solo falló en 2 pruebas, no retornando respuesta en Prueba29.txt, Prueba30.txt.
        \end{itemize}
        \begin{figure}[H]
            \centering
            \includegraphics[width=0.8\textwidth]{resources/conflicto2.jpeg}
            \caption{Gráfica del conflicto interno generado por programación dinámica.}
        \end{figure}
        \item \textbf{Algoritmo voraz:}
        \begin{itemize}
            \item Fue el más rápido en todas las pruebas, con tiempos del orden de milisegundos.
            \item No garantiza solución óptima: en todas las pruebas arrojó una solución, pero esta no siempre coincidió con el CI mínimo real, sin embargo, en promedio difiere de la respuesta óptima que arroja la programación dinámica en un 1,62 \%.
        \end{itemize}
        \begin{figure}[H]
            \centering
            \includegraphics[width=0.8\textwidth]{resources/conflicto3.jpeg}
            \caption{Gráfica del conflicto interno generado por algoritmo voraz.}
        \end{figure}
        \begin{figure}[H]
            \centering
            \includegraphics[width=0.8\textwidth]{resources/conflicto4.jpeg}
            \caption{Gráfica del conflicto interno comparando los tres metodos.}
        \end{figure}
    \end{itemize}

    \textbf{En resumen:}
    \begin{itemize}
        \item Fuerza bruta y dinámica aseguran la precisión máxima, pero no siempre pueden ejecutarse eficientemente.
        \item Voraz, aunque no garantiza optimalidad, ofrece soluciones rápidas y suficientemente cercanas a la óptima, incluso en escenarios con muchos agentes.
    \end{itemize}

    \subsection{Tiempos de Ejecución}

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.8\textwidth]{resources/tiempos.png}
        \caption{Comparativa gráfica del tiempo de respuesta obtenido por cada algoritmo.}
    \end{figure}

    En cuanto a los tiempos, es claro en la tabla que los tiempos del algoritmo voraz son mucho menores que de los demás algoritmos. A Continuación una representación gráfica de los tiempos de los tres algoritmos:

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.8\textwidth]{resources/tiempo1.jpeg}
        \caption{Gráfica comparativa del tiempo de respuesta obtenido por cada algoritmo.}
    \end{figure}

    \begin{itemize}
        \item \textbf{Fuerza bruta:}
        \begin{itemize}
            \item Su tiempo de ejecución crece exponencialmente con el número de agentes.
            \item Aunque fue rápido para pequeños casos (5 o 10 grupos), superó los 100 segundos en algunas pruebas (Prueba6.txt) y no logró 73% de las pruebas.
        \end{itemize}
        \begin{figure}[H]
            \centering
            \includegraphics[width=0.8\textwidth]{resources/tiempo2.jpeg}
            \caption{Gráfica del tiempo de respuesta obtenido por fuerza bruta.}
        \end{figure}
        \item \textbf{Programación dinámica:}
        \begin{itemize}
            \item Presenta un crecimiento más moderado, pero aún significativo en problemas grandes.
            \item Tiempos mayores a 1 minuto se observaron en los archivos con más de 50 grupos.
            \item Solo falló en 2 pruebas (Prueba29.txt, Prueba30.txt), mostrando una alta escalabilidad en comparación con fuerza bruta.
        \end{itemize}
        \begin{figure}[H]
            \centering
            \includegraphics[width=0.8\textwidth]{resources/tiempo3.jpeg}
            \caption{Gráfica del tiempo de respuesta obtenido por programación dinámica.}
        \end{figure}
        \item \textbf{Algoritmo voraz:}
        \begin{itemize}
            \item Extremadamente eficiente en tiempo. Todos los tiempos son inferiores a 0.0003 segundos.
        \end{itemize}
        \begin{figure}[H]
            \centering
            \includegraphics[width=0.8\textwidth]{resources/tiempo4.jpeg}
            \caption{Gráfica del tiempo de respuesta obtenido por algoritmo voraz.}
        \end{figure}
    \end{itemize}

    \textbf{Conclusión:}
    \begin{itemize}
        \item Si se prioriza el tiempo de ejecución, el algoritmo voraz es ideal, resolviendo virtualmente al instante.
        \item Para situaciones donde la calidad de la solución es crítica, puede preferirse programación dinámica, aunque con tiempos más elevados.
        \item Fuerza bruta solo es viable para instancias pequeñas, siendo impráctico para escenarios reales por su excesivo tiempo.
    \end{itemize}

    La siguiente tabla presenta una comparación general entre los tres enfoques implementados: fuerza bruta, programación dinámica y algoritmo voraz. Se analizan aspectos clave como eficiencia, escalabilidad y adecuación al problema:

    \begin{table}[H]
        \centering
        \renewcommand{\arraystretch}{1.5}
        \begin{tabular}{C{4cm} C{3cm} C{3.5cm} C{3.5cm}}
            \toprule
            \textbf{Criterio}                              & \textbf{Fuerza Bruta}                   & \textbf{Programación Dinámica} & \textbf{Algoritmo Voraz}              \\
            \midrule
            Complejidad Temporal                           & \( O(n(k+1)^n) \)                       & No se sabe aún                 & \( O(n \log n) \)                     \\
            Complejidad Espacial                           & \( O((k+1)^n) \)                        & No se sabe aún                 & \( O(n) \)                            \\
            ¿Siempre da la solución óptima?                & Sí                                      & Sí                             & No                                    \\
            ¿Es capaz de manejar gran cantidad de agentes? & No                                      & No se sabe aún                 & Alta                                  \\
            Aplicación recomendada                         & Problemas pequeños                      & no se aun                      & Problemas grandes                     \\
            Eficiencia en Tiempo                           & Muy baja (crece exponencialmente)       & no se aun                      & Alta (tiempo lineal o logarítmico)    \\
            Eficiencia en Espacio                          & Muy baja, requiere mucho almacenamiento & no se aun                      & Alta, requiere poco espacio adicional \\
            \bottomrule
        \end{tabular}
        \caption{Comparación general entre algoritmos.}
    \end{table}

    \textbf{Análisis general:}
    \begin{itemize}
        \item \textbf{Fuerza Bruta} es útil como referencia o verificación para instancias pequeñas. Su exactitud es total, pero su alto costo computacional limita su uso práctico a casos muy reducidos.
        \item \textbf{Programación Dinámica} logra mantener la precisión y mejorar la eficiencia respecto a la fuerza bruta. Aun así, su uso intensivo de memoria y tiempo en casos grandes representa una limitación.
        \item \textbf{Algoritmo Voraz}, aunque no garantiza la solución óptima, ofrece resultados de buena calidad en tiempos extremadamente bajos, por lo que es ideal para escenarios donde se necesita una respuesta rápida y lo más cercana a la óptima.
    \end{itemize}

    \subsection{Ventajas y Desventajas}

    El análisis de los tres algoritmos propuestos para resolver el problema de moderación del conflicto interno en redes sociales permite establecer comparaciones fundamentales en cuanto a precisión, eficiencia y aplicabilidad práctica. A continuación, se sintetizan las ventajas y desventajas más relevantes de cada enfoque:

    \subsubsection{Fuerza Bruta}

    \begin{itemize}
        \item \textbf{Ventajas:}
        \begin{itemize}
            \item Garantiza encontrar la solución óptima, al evaluar todas las posibles combinaciones.
            \item Es útil como referencia o punto de comparación para validar otros algoritmos aproximados.
            \item Implementación directa y sencilla desde el punto de vista conceptual.
        \end{itemize}
        \item \textbf{Desventajas:}
        \begin{itemize}
            \item Su complejidad temporal es exponencial, lo que lo vuelve inviable para instancias grandes.
            \item Requiere un tiempo de ejecución considerable incluso para tamaños de entrada moderados.
            \item No escala con eficiencia a redes sociales reales con cientos o miles de agentes.
        \end{itemize}
    \end{itemize}

    \subsubsection{Programación Dinámica}

    \begin{itemize}
        \item \textbf{Ventajas:}
        \begin{itemize}
            \item  Debido a que se divide el problema en subproblemas y se resuelve cada uno, se garantiza encontrar la solución óptima, en las pruebas realizadas, la solución siempre es la óptima como se puede ver.
            \item  La complejidad espacial es reducida significativamente a diferencia de fuerza bruta.
            \item Se evita hacer cálculos repetidos ya que utiliza los que ya ha hecho en otros subproblemas, haciendolá más adecuada para redes medianas y grandes donde se requiere precisión y rendimiento.
        \end{itemize}
        \item \textbf{Desventajas:}
        \begin{itemize}
            \item  Aunque su complejidad temporal mejora, se ve afectado el espacio en memoria, la complejidad espacial, con el fin de almacenar las soluciones parciales
        \end{itemize}
    \end{itemize}

    \subsubsection{Voraz}

    \begin{itemize}
        \item \textbf{Ventajas:}
        \begin{itemize}
            \item  Su ejecución es rápida y consume pocos recursos, ideal para entornos donde el tiempo de respuesta es crítico.
            \item  La implementación es sencilla y generalmente más comprensible.
            \item Escala bien para redes sociales grandes.
        \end{itemize}
        \item \textbf{Desventajas:}
        \begin{itemize}
            \item  No garantiza obtener la solución óptima, ya que toma decisiones locales sin evaluar el impacto global.
        \end{itemize}
    \end{itemize}

    \textbf{Comparación Global:} El algoritmo de fuerza bruta actúa como una línea base teórica inigualable en precisión, pero ineficiente. La programación dinámica logra un balance adecuado entre eficiencia y exactitud, mientras que el enfoque voraz se justifica principalmente cuando se requiere velocidad y se puede tolerar una aproximación. La elección del algoritmo adecuado dependerá del tamaño del problema, los recursos disponibles y el nivel de precisión requerido por la aplicación práctica.

%%%%%%% COMPARACIÓN ALGORITMOS %%%%%%% FIN

    \newpage

%%%%%%% CASOS DE PRUEBA %%%%%%% INICIO


    \section{Casos de Prueba}

    Se realizan casos de prueba para los diferentes tipos de algoritmos (fuerza bruta, programación dinámica y voraz) con el objetivo de evaluar su eficiencia, exactitud y comportamiento en diversas condiciones. Esto permite comparar qué algoritmo es más eficiente en determinados casos, poniendo a prueba su desempeño en situaciones donde el uso de memoria y capacidad de procesamiento son claves para su correcto funcionamiento. Se han llevado a cabo los siguientes casos de pruebas:

    \subsection{Caso de Prueba 1}
    \begin{flushleft}
        \includegraphics[width=\linewidth]{resources/cp1.jpeg}
    \end{flushleft}

    \subsection{Caso de Prueba 2}
    \begin{flushleft}
        \includegraphics[width=\linewidth]{resources/cp2.jpeg}
    \end{flushleft}

    \subsection{Caso de Prueba 3}
    \begin{flushleft}
        \includegraphics[width=\linewidth]{resources/cp3.jpeg}
    \end{flushleft}

    \subsection{Caso de Prueba 4}
    \begin{flushleft}
        \includegraphics[width=\linewidth]{resources/cp4.jpeg}
    \end{flushleft}

    \subsection{Caso de Prueba 5}
    \begin{flushleft}
        \includegraphics[width=\linewidth]{resources/cp5.jpeg}
    \end{flushleft}

%%%%%%% CASOS DE PRUEBA %%%%%%% INICIO


\end{document}