%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Instructivo para trabajar este documento en Overleaf
%
% 1. Crear un nuevo proyecto en Overleaf en blanco.
%
% 2. Crear una carpeta llamada "resources":
%    - En la barra lateral izquierda, haz clic en el ícono de carpeta.
%    - Haz clic en el botón "New Folder".
%    - Escribe el nombre: resources
%    - Presiona Enter o el botón "Create"
%
% 3. Subir la imagen "universidad-del-valle.png" a la carpeta "resources":
%    - Haz clic derecho sobre la carpeta "resources" recién creada.
%    - Selecciona "Upload".
%    - Elige el archivo "universidad-del-valle.png" desde tu computadora.
%
% 4. Copiar documento
%    - Elimina todo el contenido del archivo main.tex, copia y pega en él todo el contenido del presente documento
%
% 5. Compilar con el botón "Recompile" o Ctrl + s
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%% PAQUETES Y CONFIGURACIONES %%%%%%% INICIO
\documentclass[11pt,letter]{article}

% Idioma y codificación
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}

% Diseño de página
\usepackage[left=2.54cm,right=2.54cm,top=2.54cm,bottom=2.54cm]{geometry}
\usepackage{setspace}
\usepackage{float}

% Tipografía y matemáticas
\usepackage{amsmath}
\usepackage{pifont}

% Colores (debe ir antes de tcolorbox y pgfplots)
\usepackage[table,xcdraw]{xcolor}

% Gráficos y figuras
\usepackage{graphicx}
\usepackage{pgfplots}
\pgfplotsset{compat=1.18}

% Tablas y cajas
\usepackage{booktabs}
\usepackage[most]{tcolorbox}
\usepackage{mdframed}

% Algoritmos y código
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{listings}

% Referencias y notas
\usepackage{nameref}
\usepackage{natbib}
\usepackage{endnotes}

% Hipervínculos (último siempre que sea posible)
\usepackage{hyperref}

%%%%%%% PAQUETES Y CONFIGURACIONES %%%%%%% FIN


\begin{document}
\onehalfspacing

%%%%%%% PORTADA %%%%%%% INICIO
\begin{titlepage}
\centering
\includegraphics[width=0.15\textwidth]{resources/universidad-del-valle.png}\par\vspace{1cm}
{\scshape\LARGE Universidad del Valle \par}
{\scshape\Large Facultad de Ingeniería \par}
{\scshape\Large Escuela de Ingeniería de Sistemas y Computación \par}
\vspace{2cm}

{\Large \textbf{Moderando el Conflicto Interno de Opiniones en una Red Social}}\\

\vspace{2cm}
    {\large \textbf{Anderson Johan Alban Angulo - 202310006}}\\
    {\large \textbf{Andrés Felipe Asprilla Urrutia - 202224101 }}\\
    {\large \textbf{Andrés Mauricio Ortiz Bermúdez - 202110330}}\\
    {\large \textbf{Carlos Mauricio Tovar Parra - 201741699}}\\
\vspace{2cm}

    \Large\textbf{Profesor}\par
    {\large \textbf{Jesús Alexander Aranda Bueno Ph.D.}}\\
\vspace{1.4cm}
    \Large\textbf{Curso}\par
    {\large \textbf{Análisis y Diseño de Algoritmos II (750020C)}}\\
\vspace{1cm}
{\large {19 de abril de 2025}\par}
\end{titlepage}
%%%%%%% PORTADA %%%%%%% FIN

%%%%%%% INDICE %%%%%%% INICIO
\tableofcontents
%%%%%%% INDICE %%%%%%% FIN
\newpage

%%%%%%% INTRODUCCIÓN %%%%%%% INICIO
\section{Introducción}

En este proyecto se aborda el problema de la moderación del conflicto interno de opiniones en una red social ficticia, denominada ModCI. Este fenómeno se presenta cuando un mismo individuo sostiene opiniones inconsistentes frente a dos afirmaciones relacionadas con un mismo tema, lo que refleja una falta de coherencia interna. Esta incoherencia puede ser indicativa de una comprensión superficial o confusa del tema, y su presencia generalizada en una red social puede afectar la calidad del debate y la estabilidad de las posturas colectivas.

El objetivo principal del proyecto es diseñar e implementar soluciones algorítmicas que permitan reducir el conflicto interno de la red social, modificando las opiniones de algunos de sus agentes de manera estratégica, teniendo en cuenta el nivel de rigidez de cada uno y un presupuesto limitado de esfuerzo disponible. Para ello, se utilizaron y compararon tres enfoques clásicos del diseño de algoritmos: fuerza bruta, algoritmos voraces y programación dinámica.

Cada enfoque será aplicado al problema ModCI para identificar qué agentes deben ser priorizados en el proceso de ajuste de opinión, con el fin de maximizar la reducción del conflicto interno total en la red. Además de implementar los algoritmos, se realizará un análisis comparativo considerando la optimalidad de las soluciones y la eficiencia computacional de cada estrategia.

Este proyecto busca que los estudiantes pongan en práctica las técnicas aprendidas para enfrentar problemas de naturaleza combinatoria, y que sean capaces de evaluar críticamente las ventajas y limitaciones de diferentes enfoques algorítmicos, tanto desde el punto de vista teórico como práctico.
%%%%%%% INTRODUCCIÓN %%%%%%% FIN

\newpage

%%%%%%% FUNCIONES AUXILIARES %%%%%%% INICIO
\section{Funciones auxiliares}

    Se implementaron varias funciones auxiliares que permiten calcular de manera modular el esfuerzo de moderación aplicado a una red social y el conflicto interno resultante. Estas funciones son esenciales para evaluar cualquier estrategia de solución (fuerza bruta, voraz o dinámica).

    \[
\begin{aligned}
\textbf{CI} &: \text{Conflicto Interno} \\
\mathcal{RS} &: \text{Red Social} \\
o_{i,1} &: \text{Primera opinión del grupo } i \\
o_{i,2} &: \text{Segunda opinión del grupo } i \\
r_i &: \text{Rigidez del grupo } i \\
E &: \text{Estrategia de moderación}
\end{aligned}
\]


    \subsection*{1. \texttt{calcular\_conflicto}}
        Esta función estima el nivel de conflicto interno de una red social, considerando una posible estrategia de moderación. Si no se proporciona una estrategia, se asume que todos los agentes conservan sus opiniones originales. El cálculo sigue la definición de conflicto interno:
        
        \[
        CI(\mathcal{RS}) = \frac{\sum_{i=0}^{n-1} \left(n_i^\mathcal{RS} \ast \left(o_{i,1}^\mathcal{RS} - o_{i,2}^\mathcal{RS}\right)^2\right)}{n}
        \]
        
        donde $e_i$ es la cantidad de agentes moderados del grupo $i$. El conflicto se promedia respecto al número total de grupos
        
        \begin{itemize}
          \item \textbf{Entrada:} \texttt{red\_social} (lista de tuplas), \texttt{estrategia} (lista opcional).
          \item \textbf{Salida:} Valor del conflicto interno (real).
        \end{itemize}
    
    \subsection*{2. \texttt{calcular\_esfuerzo}}
        Calcula el esfuerzo total requerido para aplicar una estrategia de moderación sobre los grupos de la red. El esfuerzo se calcula como:
        
        \[
Esfuerzo(\mathcal{RS}, E) = \sum_{i=0}^{n-1} \left[ \left| o^{\mathcal{RS}}_{i,1} - o^{\mathcal{RS}}_{i,2} \right| * r^{\mathcal{RS}}_i * e_i \right]
\]

        
        \begin{itemize}
          \item \textbf{Entrada:} \texttt{red\_social}, \texttt{estrategia}.
          \item \textbf{Salida:} Esfuerzo total requerido (entero).
        \end{itemize}
    
    \subsection*{3. \texttt{calcular\_ci\_esfuerzo}}
        \label{sec:calcular_ci_esfuerzo}
        Función compuesta que retorna simultáneamente el conflicto interno y el esfuerzo total asociado a una estrategia. Es usada como función de evaluación principal por los tres enfoques de solución.
        
        \begin{itemize}
          \item \textbf{Entrada:} \texttt{red\_social}, \texttt{estrategia}.
          \item \textbf{Salida:} Tupla \texttt{(conflicto, esfuerzo)}.
        \end{itemize}
    
    \subsection*{4. \texttt{extraer\_datos\_red}} 
        Facilita la manipulación de la red social al extraer sus atributos en listas separadas.
        
        \begin{itemize}
          \item \textbf{Entrada:} \texttt{red\_social}.
          \item \textbf{Salida:} Cuádrupla de listas: \texttt{(n, opiniones\_1, opiniones\_2, rigidez)}.
        \end{itemize}

%%%%%%% FUNCIONES AUXILIARES %%%%%%% FIN
\newpage
%%%%%%% FUERZA BRUTA %%%%%%% INICIO
\section{Algoritmo Fuerza Bruta}
\subsection{Descripción}
El enfoque de fuerza bruta para resolver el problema ModCI consiste en examinar exhaustivamente todas las posibles formas en que puede distribuirse el esfuerzo disponible entre los grupos de agentes de una red social, con el fin de minimizar su conflicto interno. Este enfoque parte de la premisa de considerar cada combinación factible de cambios en las opiniones de los agentes, evaluando en cada caso el nivel de conflicto resultante. De todas las estrategias que respetan el límite de esfuerzo permitido, se elige aquella que produce el menor conflicto interno. Al contemplar el espacio completo de soluciones, este método asegura encontrar la solución óptima. No obstante, su principal desventaja radica en el elevado costo computacional que implica, lo que restringe su uso práctico a redes de tamaño reducido.

\subsection{Implementación}
La implementación del algoritmo de fuerza bruta se realizó empleando una representación estructurada de la red social como una lista de tuplas. Cada tupla modela un grupo de agentes e incluye cuatro elementos: la cantidad de individuos en el grupo, sus opiniones frente a dos afirmaciones específicas, y su nivel de rigidez al cambio de opinión.

El proceso se estructura en dos fases principales:

\begin{enumerate}
    \item \textbf{Generación Exhaustiva de Estrategias:} Se construye el conjunto completo de combinaciones posibles de moderación sobre los grupos de agentes. Para cada grupo, se consideran todos los valores enteros desde 0 hasta el número total de agentes del grupo, lo cual representa cuántos de sus miembros podrían modificar su opinión. Al combinar estas posibilidades para todos los grupos, se genera el espacio total de estrategias viables.S
    \item \textbf{Evaluación y Selección de la Mejor Estrategia:} Cada combinación es evaluada mediante la función auxiliar \nameref{sec:calcular_ci_esfuerzo}, la cual calcula tanto el conflicto interno como el esfuerzo requerido para esa estrategia. Si el esfuerzo total no supera el máximo permitido $\mathtt{R_{\text{max}}}$ y el conflicto interno es menor al mejor encontrado hasta el momento, se actualiza la mejor solución.
\end{enumerate}

El resultado final es una tupla que contiene: el conflicto interno mínimo alcanzado, el esfuerzo total utilizado y la estrategia óptima de asignación de esfuerzos.

\subsection{Pseudocódigo}
\begin{algorithm}[H]
\caption{modciFB: Estrategia óptima por fuerza bruta}
\KwIn{Una red social $RS$ como lista de tuplas $(n_i, op1_i, op2_i, rigidez_i)$ para cada grupo $i$, y un esfuerzo máximo permitido $R_{max}$}
\KwOut{Tupla $(CI_{\min}, Esfuerzo_{\text{total}}, Estrategia_{\text{óptima}})$}

$mejorCI \leftarrow \infty$ \tcp*[r]{Inicializa el conflicto mínimo como infinito}
$mejorEsfuerzo \leftarrow 0$ \tcp*[r]{Inicializa el esfuerzo asociado}
$mejorEstrategia \leftarrow []$ \tcp*[r]{Inicializa la mejor estrategia vacía}

$estrategias \leftarrow [[]]$ \tcp*[r]{Lista inicial con una estrategia vacía}

\ForEach{grupo $g_i$ en $RS$}{
    $nuevasEstrategias \leftarrow []$ \\
    \ForEach{estrategia en estrategias}{
        \For{$e \leftarrow 0$ \KwTo $n_i$}{
            $nuevasEstrategias.\text{append}(estrategia + [e])$
        }
    }
    $estrategias \leftarrow nuevasEstrategias$ \tcp*[r]{Actualizar todas las combinaciones}
}

\ForEach{estrategia $E$ en estrategias}{
    $(CI, esfuerzo) \leftarrow calcular\_ci\_esfuerzo(RS, E)$ \\
    \If{$esfuerzo \leq R_{max}$ \textbf{and} $CI < mejorCI$}{
        $mejorCI \leftarrow CI$ \\
        $mejorEsfuerzo \leftarrow esfuerzo$ \\
        $mejorEstrategia \leftarrow E$
    }
}

\Return $(mejorCI, mejorEsfuerzo, mejorEstrategia)$
\end{algorithm}


\definecolor{lightgray}{rgb}{0.9,0.9,0.9}
\lstset{
    language=Python,
    backgroundcolor=\color{lightgray},
    frame=single,
    rulecolor=\color{black}
}

\subsection{Complejidad}
\subsubsection{Complejidad Temporal}

El algoritmo de fuerza bruta tiene una complejidad temporal exponencial, debido a que genera y evalúa todas las posibles combinaciones de esfuerzos para los grupos de la red. Si hay $n$ grupos y cada grupo tiene $k_i$ personas, entonces el número total de combinaciones posibles es:

\[
O\left(\prod_{i=1}^{n}(k_i + 1)\right)
\]

En el peor de los casos, si todos los grupos tienen un tamaño máximo de $k$, la complejidad se puede expresar como:

\[
O\left((k + 1)^n\right)
\]

Además, para cada combinación se evalúa el conflicto interno y el esfuerzo total, lo que implica un recorrido lineal sobre los $n$ grupos. Por lo tanto, la complejidad final del algoritmo es:

\[
O\left(n (k + 1)^n\right)
\]

Esto lo convierte en un algoritmo extremadamente costoso computacionalmente, ya que el tiempo de ejecución crece exponencialmente con el número de grupos y el tamaño de cada uno. Aunque garantiza una solución óptima, este enfoque no es adecuado para instancias grandes del problema.

En términos prácticos, esta complejidad significa que incluso para valores moderados de $n$ y $k$, el número total de combinaciones puede volverse inmanejable. Por ejemplo, si se tienen apenas 10 grupos de tamaño 10, el algoritmo tendría que evaluar $(10 + 1)^{10} = 25937424601$ combinaciones posibles.

\subsubsection{Complejidad Espacial}

La complejidad espacial también es considerable. El algoritmo almacena en memoria todas las combinaciones posibles de esfuerzos antes de evaluarlas. Por tanto, en el peor de los casos, el número de combinaciones almacenadas es:

\[
{O}\left((k+1)^n\right)
\]

donde $n$ es la cantidad de grupos y $k$ el número máximo de agentes por grupo. Esto se debe a que se construye la lista completa de estrategias (vectores de tamaño $n$), en la cual cada componente puede tomar un valor entre $0$ y $k$.

Este costo espacial es resultado del uso de listas auxiliares que mantienen todas las estrategias posibles en memoria antes de su evaluación, lo que puede saturar rápidamente la memoria en problemas con muchos grupos o agentes.

\subsection{Corrección}

El algoritmo de fuerza bruta desarrollado para el problema ModCI garantiza la 
obtención de la solución óptima, ya que evalúa exhaustivamente todas las 
combinaciones posibles de distribución de esfuerzos entre los grupos de la red 
social. Para cada combinación generada, calcula el nivel de conflicto interno 
resultante y verifica que el esfuerzo total no supere el límite máximo permitido. 
Posteriormente, selecciona la estrategia que logra minimizar el conflicto interno 
dentro de las restricciones establecidas. 

Sin embargo, aunque el algoritmo es correcto desde el punto de vista funcional, su 
ejecución implica una búsqueda exhaustiva de soluciones que conlleva una 
complejidad exponencial. A medida que aumenta el número de grupos o el tamaño 
de estos, el número de combinaciones crece de forma drástica, lo cual impacta 
negativamente en el rendimiento. Esto limita su aplicabilidad a redes de pequeño 
tamaño, donde aún es viable computacionalmente. 
Por lo tanto, si bien este enfoque asegura una solución óptima y es útil como 
referencia o para validar la calidad de soluciones aproximadas, no es práctico para 
redes sociales grandes, y por ello es necesario acudir a técnicas más eficientes 
como los algoritmos voraces o la programación dinámica para abordar instancias 
más complejas del problema.

\subsection{Análisis}

A continuación se presenta un análisis concreto que permite ilustrar el funcionamiento paso a paso del algoritmo de fuerza bruta

\textbf{Datos de entrada:}

\begin{table}[ht]
\centering
\begin{tabular}{cccccc}
\toprule
\textbf{Grupo} & \textbf{Agentes} & \textbf{Opinión 1} & \textbf{Opinión 2} & \textbf{Rigidez} \\
\midrule
1 & 1 & -4 & 2 & 0.1 \\
2 & 4 & 1 & -1 & 0.2 \\
3 & 3 & 3 & 0 & 0.5 \\
\bottomrule
$R_{\text{max}} = 5$
\end{tabular}
\caption{Datos entrada: análisis fuerza bruta}
\end{table}


\subsubsection*{Análisis del proceso}
El paso a paso para generar la solución en el algoritmo de fuerza bruta es el siguiente:
\begin{enumerate}
    \item \textbf{Generación de combinaciones posibles}: Se generan todas las combinaciones de esfuerzos posibles para los grupos, respetando el rango desde 0 hasta el número de agentes por grupo.
    
    En este caso:
    \begin{itemize}
        \item Grupo 1: $0$ a $1$ (2 opciones)
        \item Grupo 2: $0$ a $4$ (5 opciones)
        \item Grupo 3: $0$ a $1$ (2 opciones)
    \end{itemize}

    Total de combinaciones: $2 \times 5 \times 2 = 20$

    \item \textbf{Cálculo del conflicto interno (CI)}: Se calcula el conflicto interno para cada combinación válida, considerando cuántos agentes permanecen sin moderar. Usando la función \nameref{sec:calcular_ci_esfuerzo}.
    \item \textbf{Cálculo del esfuerzo total por combinación}: Se calcula el esfuerzo total requerido usando la misma función auxiliar.
    
    \item \textbf{Filtrado por esfuerzo máximo permitido ($R_{\text{max}}$)}: Se descartan combinaciones cuyo esfuerzo supere el valor de $R_{\text{max}} = 5$.

    \item \textbf{Selección de la mejor estrategia}: De las combinaciones válidas, se selecciona la que genere el menor conflicto interno.
\end{enumerate}

\textbf{Combinaciones posibles (20 en total):}

\begin{center}
\renewcommand{\arraystretch}{1.2}
\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{cccc}
\toprule
\textbf{Combinación (G1 - G2 - G3)} & \textbf{Esfuerzo Total} & \textbf{Conflicto Interno} & \textbf{Válida} \\
\midrule
0 - 0 - 0 & 0 & 29.3333 & \ding{51} \\
\rowcolor{gray!10} 0 - 0 - 1 & 1 & 21.3333 & \ding{51} \\
0 - 0 - 2 & 2 & 25.3333 & \ding{51} \\
0 - 1 - 0 & 1 & 27.3333 & \ding{51} \\
0 - 1 - 1 & 2 & 17.3333 & \ding{51} \\
\rowcolor{gray!10} 0 - 2 - 0 & 2 & 21.3333 & \ding{51} \\
0 - 2 - 1 & 3 & 13.3333 & \ding{51} \\
0 - 3 - 0 & 3 & 17.3333 & \ding{51} \\
0 - 3 - 1 & 4 & 9.3333 & \ding{55} \\
0 - 4 - 0 & 4 & 13.3333 & \ding{55} \\
0 - 4 - 1 & 5 & 5.3333 & \ding{55} \\
1 - 0 - 0 & 1 & 25.3333 & \ding{51} \\
\rowcolor{gray!10}\textbf{1 - 0 - 1} & \textbf{6} & \textbf{21.3333} & \ding{72} \\
\rowcolor{gray!10} 1 - 1 - 0 & 2 & 21.3333 & \ding{51} \\
1 - 1 - 1 & 3 & 13.3333 & \ding{55} \\
1 - 2 - 0 & 3 & 17.3333 & \ding{51} \\
1 - 2 - 1 & 4 & 9.3333 & \ding{55} \\
1 - 3 - 0 & 4 & 13.3333 & \ding{55} \\
1 - 3 - 1 & 5 & 5.3333 & \ding{55} \\
1 - 4 - 0 & 5 & 9.3333 & \ding{55} \\
1 - 4 - 1 & 6 & 1.3333 & \ding{55} \\
\bottomrule
\end{tabular}
\caption{Combinaciones posibles fuerza bruta}
\end{table}
\end{center}



\textbf{¿Por qué el algoritmo eligió la de mayor esfuerzo si el conflicto era igual?}

\textbf{Inferencia:} El algoritmo busca la \textit{primera combinación} con el menor conflicto.

\begin{itemize}
    \item \textbf{Paso 1:} Recorre las combinaciones en orden (como las va generando).
    \item \textbf{Paso 2:} Guarda la primera que cumpla con:
    \begin{itemize}
        \item Esfuerzo $\leq R_{\text{max}}$
        \item Menor conflicto interno encontrado hasta el momento.
    \end{itemize}
\end{itemize}

\vspace{0.5em}

\textbf{Resolución:}
\begin{itemize}
    \item Encuentra \texttt{1 - 0 - 1} con conflicto $21.33 \rightarrow$ lo guarda. \ding{72}
    \item Luego llega a \texttt{1 - 1 - 0} con mismo conflicto, pero como no mejora el conflicto, no actualiza aunque tenga menor esfuerzo.
\end{itemize}


\subsection*{Resultados Finales del Algoritmo}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|}
\hline
\rowcolor[HTML]{EFEFEF}
\textbf{Métrica} & \textbf{Valor} \\
\hline
Estrategia óptima & {[}1, 0, 1{]} \\
\hline
Conflicto interno & 213.333 \\
\hline
Esfuerzo total & 4 \\
\hline
Tiempo de ejecución & 0.0001 segundos \\
\hline
\end{tabular}
\caption{Resultados obtenidos: análisis fuerza bruta.}
\end{table}

Este ejemplo ilustra cómo el algoritmo de fuerza bruta explora exhaustivamente todas las posibles combinaciones de esfuerzos para encontrar la que minimice el conflicto interno. Aunque este enfoque garantiza encontrar la solución óptima, tiene una complejidad exponencial, ya que el número de combinaciones crece rápidamente con cada grupo o incremento de agentes.

En esta prueba con solo 3 grupos y 20 combinaciones, el tiempo de ejecución fue casi instantáneo, lo que demuestra que para problemas pequeños es muy efectivo. Sin embargo, en problemas reales con muchos grupos o agentes, este enfoque se vuelve inviable por el alto costo computacional, siendo recomendable en esos casos el uso de algoritmos voraces o programación dinámica.

\subsection{Impacto en el Rendimiento}
\label{sec:limitaciones_fuerza_bruta}

A pesar de su simplicidad, el enfoque de fuerza bruta presenta importantes limitaciones prácticas. Una de las más críticas es el impacto que tiene sobre el rendimiento a medida que crece el tamaño de la red social o el número de agentes por grupo.

Supongamos que la red social está compuesta por \( n \) grupos, y que cada grupo \( i \) tiene \( a_i \) agentes. Como las estrategias posibles para cada grupo van desde moderar 0 hasta \( a_i \) agentes, entonces el número de combinaciones de estrategias posibles es:

\[
\prod_{i=1}^{n} (a_i + 1)
\]

Este crecimiento es exponencial en el número de grupos, y además está influenciado por el tamaño de cada grupo. Incluso si cada grupo tuviera pocos agentes, al multiplicar las posibilidades de todos los grupos, el total de combinaciones puede escalar rápidamente.

Por ejemplo, para un conjunto de grupos con tamaños heterogéneos, como:

\[
\left\{ a_1, a_2, \ldots, a_n \right\}
\]

...el total de estrategias a evaluar será:

\[
(a_1 + 1) \cdot (a_2 + 1) \cdot \ldots \cdot (a_n + 1)
\]
Cada una de estas combinaciones debe ser evaluada para calcular su conflicto interno y su esfuerzo total, lo que implica un costo computacional adicional por iteración.
\vspace{1em}
\noindent
\begin{tcolorbox}[colback=red!5!white, colframe=red!50!black, title=Advertencia sobre rendimiento]
 Aunque el algoritmo garantiza encontrar la solución óptima, el tiempo de ejecución crece de forma multiplicativa con la cantidad de grupos y el tamaño de cada uno, lo que puede llevar a tiempos de ejecución inaceptables en redes sociales grandes.

En estos casos, se vuelve recomendable recurrir a algoritmos de programación dinámica, que también garantiza la solución óptima en menor tiempo o voraces que sacrifican algo de precisión a cambio de un rendimiento mucho más eficiente.
\end{tcolorbox}



%%%%%%% FUERZA BRUTA %%%%%%% FIN
\newpage

%%%%%%% ALGORITMO DINÁMICO %%%%%%% INICIO
\section{Algoritmo Dinámico}
\subsection{Descripción}

El algoritmo de programación dinámica aplicado en este proyecto busca minimizar el conflicto interno dentro de una red social, bajo la restricción de un presupuesto limitado de esfuerzo (denotado como $R_{\text{max}}$). Este conflicto surge de las diferencias de opinión entre los agentes de distintos grupos, y puede ser mitigado parcialmente moderando a algunos de estos agentes, a costa de cierto esfuerzo.

A diferencia de enfoques exhaustivos como la fuerza bruta, que evalúan todas las combinaciones posibles de moderación, este algoritmo divide el problema en subproblemas más pequeños y los resuelve de manera progresiva y óptima, reutilizando resultados previamente calculados para construir la solución global.

El proceso se fundamenta en el principio de \textit{optimalidad de Bellman}, que asegura que una solución óptima para el problema completo puede ser construida a partir de soluciones óptimas de sus subproblemas.

A cada paso, el algoritmo evalúa todas las opciones posibles de moderación para un grupo específico —desde no moderar a ningún agente hasta moderar a todos— y calcula el conflicto y esfuerzo que implicaría esa decisión. Luego, actualiza de forma eficiente una estructura de datos que almacena, para cada cantidad de esfuerzo acumulado, la mejor configuración encontrada hasta ese punto.

Al finalizar, se selecciona la estrategia que, sin superar el esfuerzo disponible, logra el menor conflicto interno posible.

Este enfoque garantiza que la solución obtenida es óptima dentro de las restricciones definidas, y resulta mucho más escalable que evaluar explícitamente todas las combinaciones posibles, especialmente en redes sociales con un número elevado de grupos o agentes.

\subsection{Pasos Programación Dinámica}
Sabemos que para calcular la solución óptima para un algoritmo dinámico se deben 
cumplir ciertos aspectos:
\begin{enumerate}
    \item Caracterizar la solución óptima (Subestructura óptima) 
    \item Definir recursivamente el valor de la solución óptima
    \item Calcular el valor de la solución óptima (algoritmo) 
    \item Construir la solución óptima (algoritmo)
\end{enumerate}

\subsubsection{Caracterizando la Estructura de una Solución Óptima}

Para resolver el problema de minimizar el conflicto interno en una red social bajo una restricción de esfuerzo máximo permitido ($R_{\text{max}}$), es necesario comprender cómo se construye la solución óptima a partir de decisiones locales en cada grupo de agentes.

\begin{itemize}
    \item \textbf{Definición del problema original:}
    
    Denotamos el problema general como:
    \[
        \text{MinCI}(Grupos_n, R_{\text{max}})
    \]
    donde:
    \begin{itemize}
        \item $Grupos_n$: conjunto de $n$ grupos sociales.
        \item $R_{\text{max}}$: esfuerzo total máximo permitido.
        \item $\text{MinCI}$: equivale a la función objetivo del problema, que llamamos \texttt{ModCI}.
    \end{itemize}
    
    \item \textbf{Subproblemas:}
    
    El enfoque de programación dinámica divide el problema en subproblemas de la forma:
    \[
        \text{MinCI}(Grupos_i, R_j)
    \]
    donde:
    \begin{itemize}
        \item $i$ representa los primeros $i$ grupos, con $1 \leq i \leq n$
        \item $R_j$ representa el esfuerzo disponible en ese momento, con $0 \leq j \leq R_{\text{max}}$
    \end{itemize}
    
    \item \textbf{Recurrencia y decisiones:}
    
    Para cada grupo $i$, se evalúan todas las decisiones posibles de moderación: desde moderar a $0$ hasta moderar a $n_i$ agentes (cantidad total del grupo). A cada opción le corresponde un coste de esfuerzo $e$ y un conflicto potencial.
    
    La decisión óptima para el subproblema $\text{MinCI}(Grupos_i, R_j)$ se construye a partir de:
    \begin{itemize}
        \item Las decisiones óptimas de los subproblemas anteriores ($i - 1$).
        \item Comparando todas las combinaciones posibles de moderación:
        \[
            e \in [0, n_i]
        \]
        \item Solo se consideran las combinaciones que cumplen:
        \[
            Costo(e) \leq R_j
        \]
    \end{itemize}
    
    Para cada combinación válida, se calcula:
    \[
        CI_{\text{acumulado}} = CI_{\text{previo}} + (n_i - e)(o_{1i} - o_{2i})^2
    \]
    
    donde:
    \begin{itemize}
        \item $CI_{\text{acumulado}}$: conflicto total acumulado hasta el grupo actual $i$, considerando la estrategia de esfuerzo aplicada.
        \item $CI_{\text{previo}}$: conflicto acumulado hasta el grupo $i - 1$, correspondiente a una asignación de esfuerzo previa.
        \item $n_i$: número total de agentes en el grupo $i$.
        \item $e$: número de agentes moderados en el grupo $i$.
        \item $n_i - e$: número de agentes no moderados en el grupo $i$.
        \item $(o_{1i} - o_{2i})$: diferencia cuadrática entre las dos opiniones del grupo. Refleja la intensidad del conflicto si no se modera ese grupo.
    \end{itemize}
    
    \item \textbf{Estructura óptima:}
    
    Así, la solución óptima para el problema completo:
    \[
        \text{MinCI}(Grupos_n, R_{\text{max}})
    \]
    se obtiene reutilizando las mejores soluciones de los subproblemas previos, considerando todas las configuraciones posibles de esfuerzo y moderación por grupo.
\end{itemize}

Esto permite:
\begin{itemize}
    \item Mantener un historial de las mejores decisiones hasta cada punto.
    \item Evitar recalcular combinaciones ya exploradas.
    \item Garantizar una solución óptima dentro del límite de esfuerzo.
\end{itemize}

\subsubsection{Definiendo Recursivamente el Valor de la Solución Óptima}

Una vez caracterizada la subestructura óptima, necesitamos definir una fórmula recursiva que describa cómo se calcula el valor de la solución óptima a partir de los subproblemas.

\begin{itemize}
    \item \textbf{Variables:}
    \begin{itemize}
        \item $i$: índice del grupo actual ($0$-indexado)
        \item $e$: número de agentes moderados en el grupo $i$ ($0 \leq e \leq n_i$)
        \item $c(i, e)$: esfuerzo necesario para moderar $e$ agentes en el grupo $i$
        \item $(o_{1i}, o_{2i})$: distancia cuadrática de opiniones en el grupo $i$
        \item $S(i, j)$: valor mínimo del conflicto interno al considerar los primeros $i$ grupos con un total de esfuerzo $j$
    \end{itemize}

    \item \textbf{Recurrencia:}
    \[
    S(i, j) = \min_{0 \leq e \leq n_i,\, c(i,e) \leq j} \left\{ S(i - 1, j - c(i, e)) + (n_i - e) \cdot d_i \right\}
    \]

    \item \textbf{Explicación:}
    \begin{itemize}
        \item Para cada grupo $i$, evaluamos todas las posibles cantidades de agentes $e$ que podrían moderarse.
        \item El costo en esfuerzo por moderar $e$ agentes se calcula como:
        \[
            c(i, e) = \lceil |o_{1i} - o_{2i}| \cdot rigidez_i \cdot e \rceil
        \]
        \item Si ese esfuerzo no supera el total disponible $j$, entonces actualizamos el conflicto acumulado:
        \begin{itemize}
            \item Se agrega el impacto de los $n_i - e$ agentes no moderados, que contribuyen al conflicto interno con el factor $d_i$.
        \end{itemize}
        \item De todas las combinaciones viables, nos quedamos con la que minimice el conflicto total.
    \end{itemize}

    \item \textbf{Condiciones triviales:}
    \[
    S(-1, 0) = 0
    \]
    \[
    S(-1, j) = \infty, \quad \text{si } j > 0
    \]

    Esto indica que al inicio, sin haber procesado ningún grupo, solo se puede tener un conflicto acumulado 0 si no se ha usado esfuerzo. Todo lo demás es inválido.

    \subsubsection{Calculando el Valor de la Solución Óptima}
    \subsubsection{Construyendo la Solución Óptima}
    \subsubsection{¿Cuántos Subproblemas Hay?}
    \subsection{Implementación}
    \subsection{Pseudocódigo}
    \subsection{Complejidad}
    \subsubsection{Complejidad Temporal}
    \subsubsection{Complejidad Espacial}
    \subsubsection{¿Es Útil en la Práctica}
    \paragraph{Hipótesis}
    \paragraph{Conclusión Hipótesis Temporal}
    \paragraph{Conclusión Hipótesis Espacial}
    \subsection{¿El Algoritmo Siempre da la Respuesta Correcta al Problema}
    \subsection{Análisis}
    \subsection{Impacto en El Rendimiento}
    
\end{itemize}

%%%%%%% ALGORITMO DINÁMICO %%%%%%% FIN

\newpage

%%%%%%% ALGORITMO VORAZ %%%%%%% INICIO
\section{Algoritmo Voraz}

\subsection{Descripción}
El algoritmo voraz implementado aborda el problema de minimizar el conflicto interno dentro de una red social, sujeto a una restricción presupuestal de esfuerzo (denotada como $R_{max}$). El conflicto surge a partir de las discrepancias entre las opiniones que los agentes expresan sobre dos afirmaciones, y puede ser reducido moderando a ciertos agentes, aunque dicha acción implica un costo en términos de esfuerzo.

A diferencia del enfoque de fuerza bruta, que explora exhaustivamente todas las combinaciones posibles de moderación, y del enfoque de programación dinámica, que construye soluciones óptimas a partir de subproblemas más pequeños, este enfoque se basa en una estrategia de decisión secuencial que busca aprovechar el esfuerzo disponible de la forma más eficiente posible. Para ello, cada grupo de agentes es evaluado según un criterio heurístico que estima la utilidad relativa de intervenir sobre él.

Este enfoque no garantiza encontrar la solución óptima al problema, ya que no explora todo el espacio de posibilidades. Sin embargo, en muchos casos ofrece soluciones de buena calidad con un costo computacional mucho menor, lo que lo convierte en una opción atractiva para redes sociales de mayor tamaño o para situaciones donde el tiempo de cómputo es limitado.

\subsection{Definición de la heurística}

La toma de decisiones del algoritmo voraz se fundamenta en una heurística que asigna una utilidad a cada grupo de agentes, con el propósito de priorizar aquellos cuya moderación podría ser más efectiva en términos de reducción del conflicto interno por unidad de esfuerzo.

La utilidad asignada a cada grupo se define como:

\[
\text{utilidad}_i = \frac{|op1_i - op2_i|}{\max(rigidez_i, \varepsilon)}
\]

donde:
\begin{itemize}
    \item $op1_i$ y $op2_i$ son las opiniones del grupo $i$ frente a las dos afirmaciones del problema,
    \item $rigidez_i$ es el nivel de resistencia al cambio de opinión del grupo $i$,
    \item $\varepsilon$ es una constante positiva muy pequeña que evita divisiones por cero.
\end{itemize}

Esta función favorece a los grupos que presentan una alta discrepancia de opiniones y baja rigidez, es decir, aquellos en los que intervenir podría tener mayor impacto y menor costo relativo.

Una vez calculadas las utilidades para todos los grupos, se ordenan en orden descendente y se asigna el esfuerzo disponible comenzando por los grupos más rentables, hasta agotar el presupuesto permitido $R_{max}$ o no poder realizar más asignaciones viables.

\subsection{¿Entendimos el Algoritmo?}
\subsubsection{Solución del Ejercicio 2.3.1}

Consideramos la red social $\mathcal{RS}_1 = ( \langle 3, -100, 50, 0.5 \rangle, \langle 1, 100, 80, 0.1 \rangle, \langle 1, -10, 0, 0.5 \rangle, R_{max} = 80 )$, compuesta por tres grupos de agentes. La información detallada de los grupos es la siguiente:

\begin{table}[H]
\centering
\begin{tabular}{c|c|c|c|c}
\textbf{Grupo} & $n_i$ (agentes) & $o_{i1}$ & $o_{i2}$ & $r_i $ (rigidez) \\
\hline
0 & 3 & -100 & 50 & 0.5 \\
1 & 1 & 100 & 80 & 0.1 \\
2 & 1 & -10 & 0 & 0.5 \\
\end{tabular}
\caption{Datos de entrada de la red social $\mathcal{RS}_1$}
\end{table}

\subsubsection*{Paso 1: Cálculo de utilidad y costo unitario}

Calculamos para cada grupo su utilidad según la \nameref{sec:Definición de la Heurística}) y el costo de moderar a un solo agente:

\begin{table}[H]
\centering
\begin{tabular}{c|c|c}
\textbf{Grupo} & Utilidad heurística & Costo unitario por agente \\
\hline
0 & $\frac{|-100 - 50|}{0.5} = 300$ & $\lceil 150 \cdot 0.5 \rceil = 75$ \\
1 & $\frac{|100 - 80|}{0.1} = 200$ & $\lceil 20 \cdot 0.1 \rceil = 2$ \\
2 & $\frac{|-10 - 0|}{0.5} = 20$ & $\lceil 10 \cdot 0.5 \rceil = 5$ \\
\end{tabular}
\caption{Utilidades y costos unitarios de la red social $\mathcal{RS}_1$}
\end{table}

\subsubsection*{Paso 2: Orden de prioridad por utilidad}

Ordenamos los grupos en orden descendente según su utilidad:

\begin{enumerate}
    \item Grupo 0: utilidad 300
    \item Grupo 1: utilidad 200
    \item Grupo 2: utilidad 20
\end{enumerate}

\subsubsection*{Paso 3: Asignación de esfuerzo}

Inicializamos $R_{\text{max}} = 80$.

\begin{itemize}
    \item \textbf{Grupo 0}:
        \begin{itemize}
            \item Costo unitario: 75
            \item Máximo posible: $\left\lfloor \frac{80}{75} \right\rfloor = 1$ agente
            \item Se asigna: 1 agente
            \item Nuevo $R_{\text{max}} = 80 - 75 = 5$
        \end{itemize}

    \item \textbf{Grupo 1}:
        \begin{itemize}
            \item Costo unitario: 2
            \item Máximo posible: $\left\lfloor \frac{5}{2} \right\rfloor = 2$, pero el grupo tiene solo 1 agente
            \item Se asigna: 1 agente
            \item Nuevo $R_{\text{max}} = 5 - 2 = 3$
        \end{itemize}

    \item \textbf{Grupo 2}:
        \begin{itemize}
            \item Costo unitario: 5
            \item Máximo posible: $\left\lfloor \frac{3}{5} \right\rfloor = 0$
            \item No se asignan agentes
        \end{itemize}
\end{itemize}

\subsubsection*{Resultado parcial de la estrategia}

\begin{itemize}
    \item \textbf{Estrategia aplicada ($E_V$): } $[1, 1, 0]$
    \item \textbf{Esfuerzo total utilizado:} $75 + 2 = 77$
\end{itemize}

\subsubsection*{Cálculo del conflicto interno}

La siguiente tabla muestra, grupo por grupo, cómo se calcula el conflicto interno de la red tras aplicar la estrategia $E_V = [1, 1, 0]$:

\begin{table}[H]
\centering
\begin{tabular}{c|c|c|c|c|c}
\textbf{Grupo} & $n_i$ & $e_i$ & $n_i - e_i$ (no moderados) & $(o_{i1} - o_{i2})^2$ & Aporte al CI \\
\hline
0 & 3 & 1 & 2 & $(-100 - 50)^2 = 22500$ & $2 \cdot 22500 = 45000$ \\
1 & 1 & 1 & 0 & $(100 - 80)^2 = 400$ & $0 \cdot 400 = 0$ \\
2 & 1 & 0 & 1 & $(-10 - 0)^2 = 100$ & $1 \cdot 100 = 100$ \\
\hline
\multicolumn{5}{r|}{\textbf{Suma total}} & 45100 \\
\end{tabular}
\caption{Cálculo del conflicto interno con la estrategia $E_V$ para $\mathcal{RS}_1$}
\end{table}

\textbf{Conflicto interno resultante:} $\frac{45100}{3} \approx 15033.33$

\subsubsection*{Resultado final}

\begin{itemize}
    \item \textbf{Estrategia aplicada:} $[1, 1, 0]$
    \item \textbf{Esfuerzo total utilizado:} $77$
    \item \textbf{Conflicto interno resultante:} $\approx 15033.33$
\end{itemize}

\subsubsection*{Análisis final y respuestas a las preguntas del ejercicio}

Para la red social $\mathcal{RS}_1$ se compararon tres estrategias:

\begin{itemize}
    \item \textbf{Estrategia $E_1$}: $[0, 1, 1]$, con esfuerzo total $7$ y conflicto interno $22500$
    \item \textbf{Estrategia $E_2$}: $[1, 0, 0]$, con esfuerzo total $75$ y conflicto interno $15166.66$
    \item \textbf{Estrategia $E_V$}: $[1, 1, 0]$, con esfuerzo total $77$ y conflicto interno $\approx 15033.33$
\end{itemize}

A partir de estos resultados, respondemos las preguntas planteadas:

\begin{itemize}
    \item \textbf{¿Habrá mejores soluciones que $E_2$?} \\
    Sí. La estrategia $E_V$ encontrada por el algoritmo voraz logra un menor nivel de conflicto interno ($\approx 15033.33$) que $E_2$ ($15166.66$), y sigue siendo aplicable dentro del esfuerzo permitido ($77 \leq 80$). Además, esta estrategia fue verificada con el enfoque de fuerza bruta, confirmando que es la solución óptima para esta instancia.

    \item \textbf{¿Habrá estrategias de moderación no aplicables?} \\
    Sí. Por ejemplo, la estrategia $[2, 1, 1]$ (es decir, moderar a 2 agentes del grupo 0, 1 del grupo 1 y 1 del grupo 2) resulta en un esfuerzo total de:
    \[
    \lceil 150 \cdot 0.5 \cdot 2 \rceil + \lceil 20 \cdot 0.1 \cdot 1 \rceil + \lceil 10 \cdot 0.5 \cdot 1 \rceil = 150 + 2 + 5 = 157
    \]
    lo cual excede el límite $R_{max} = 80$. Por tanto, no es aplicable.

\end{itemize}



\subsubsection{Solución del Ejercicio 2.3.2}

Consideramos la red social $RS2 = ( \langle 3, -100, 100, 0.8 \rangle, \langle 2, 100, 80, 0.5 \rangle, \langle 4, -10, 10, 0.5 \rangle, R_{max} = 400 )$, compuesta por tres grupos de agentes. La información detallada de los grupos es la siguiente:

\begin{table}[H]
\centering
\begin{tabular}{c|c|c|c|c}
\textbf{Grupo} & $n_i$ (agentes) & $o_{i1}$ & $op_{i2}$ & $r_i$ (rigidez) \\
\hline
0 & 3 & -100 & 100 & 0.8 \\
1 & 2 & 100 & 80 & 0.5 \\
2 & 4 & -10 & 10 & 0.5 \\
\end{tabular}
\caption{Datos de entrada de la red social $\mathcal{RS}_2$}
\end{table}

\subsubsection*{Paso 1: Cálculo de utilidad y costo unitario}

Calculamos para cada grupo su utilidad según la \nameref{sec:Definición de la Heurística}) y el costo de moderar a un solo agente:

\begin{table}[H]
\centering
\begin{tabular}{c|c|c}
\textbf{Grupo} & Utilidad heurística & Costo unitario por agente \\
\hline
0 & $\frac{|-100 - 100|}{0.8} = 250$ & $\lceil 200 \cdot 0.8 \rceil = 160$ \\
1 & $\frac{|100 - 80|}{0.5} = 40$ & $\lceil 20 \cdot 0.5 \rceil = 10$ \\
2 & $\frac{|-10 - 10|}{0.5} = 40$ & $\lceil 20 \cdot 0.5 \rceil = 10$ \\
\end{tabular}
\caption{Utilidades y costos unitarios de la red social $\mathcal{RS}_2$}
\end{table}

\subsubsection*{Paso 2: Orden de prioridad por utilidad}

Ordenamos los grupos en orden descendente según su utilidad:

\begin{enumerate}
    \item Grupo 0: utilidad 250
    \item Grupo 1: utilidad 40
    \item Grupo 2: utilidad 40
\end{enumerate}

\subsubsection*{Paso 3: Asignación de esfuerzo}

Inicializamos $R_{\text{max}} = 400$.

\begin{itemize}
    \item \textbf{Grupo 0}:
        \begin{itemize}
            \item Costo unitario: 160
            \item Máximo posible: $\left\lfloor \frac{400}{160} \right\rfloor = 2$, pero el grupo tiene solo 3 agentes
            \item Se asigna: 2 agentes
            \item Nuevo $R_{\text{max}} = 400 - 2 \cdot 160 = 80$
        \end{itemize}

    \item \textbf{Grupo 1}:
        \begin{itemize}
            \item Costo unitario: 10
            \item Máximo posible: $\left\lfloor \frac{80}{10} \right\rfloor = 8$, pero el grupo tiene solo 2 agentes
            \item Se asigna: 2 agentes
            \item Nuevo $R_{\text{max}} = 80 - 2 \cdot 10 = 60$
        \end{itemize}

    \item \textbf{Grupo 2}:
        \begin{itemize}
            \item Costo unitario: 10
            \item Máximo posible: $\left\lfloor \frac{60}{10} \right\rfloor = 6$, pero el grupo tiene solo 4 agentes
            \item Se asigna: 4 agentes
            \item Nuevo $R_{\text{max}} = 60 - 4 \cdot 10 = 20$
        \end{itemize}
\end{itemize}

\subsubsection*{Resultado parcial de la estrategia}

\begin{itemize}
    \item \textbf{Estrategia aplicada ($E_V$): } $[2, 2, 4]$
    \item \textbf{Esfuerzo total utilizado:} $2 \cdot 160 + 2 \cdot 10 + 4 \cdot 10 = 320 + 20 + 40 = 380$
\end{itemize}

\subsubsection*{Cálculo del conflicto interno}

La siguiente tabla muestra, grupo por grupo, cómo se calcula el conflicto interno de la red tras aplicar la estrategia $E = [2, 2, 4]$:

\begin{table}[H]
\centering
\begin{tabular}{c|c|c|c|c|c}
\textbf{Grupo} & $n_i$ & $e_i$ & $n_i - c_i$ (no moderados) & $(o1_i - o2_i)^2$ & Aporte al CI \\
\hline
0 & 3 & 2 & 1 & $( -100 - 100 )^2 = 40000$ & $1 \cdot 40000 = 40000$ \\
1 & 2 & 2 & 0 & $(100 - 80)^2 = 400$ & $0$ \\
2 & 4 & 4 & 0 & $(-10 - 10)^2 = 400$ & $0$ \\
\hline
\multicolumn{5}{r|}{\textbf{Suma total}} & 40000 \\
\end{tabular}
\caption{Cálculo del conflicto interno con la estrategia $E_V$ para $\mathcal{RS}_2$}
\end{table}

\textbf{Conflicto interno resultante:} $\frac{40000}{3} \approx 13333.33$

\subsubsection*{Resultado final}

\begin{itemize}
    \item \textbf{Estrategia aplicada:} $[2, 2, 4]$
    \item \textbf{Esfuerzo total utilizado:} $380$
    \item \textbf{Conflicto interno resultante:} $\approx 13333.33$
\end{itemize}

\subsubsection*{Análisis final y respuestas a las preguntas del ejercicio}

En este ejercicio se compararon tres estrategias de moderación aplicables a la red social $RS2$:

\begin{itemize}
    \item \textbf{Estrategia $E_1$}: $[0, 1, 2]$ con esfuerzo total $30$ y conflicto interno $40400$
    \item \textbf{Estrategia $E_2$}: $[2, 2, 2]$ con esfuerzo total $360$ y conflicto interno $13600$
    \item \textbf{Estrategia $E_{V}$}: $[2, 2, 4]$ con esfuerzo total $380$ y conflicto interno $\approx 13333.33$
\end{itemize}

A partir de esta comparación, respondemos a las preguntas planteadas:

\begin{itemize}
    \item \textbf{¿Habrá mejores soluciones que $E_2$?} \\
    Sí. La estrategia encontrada mediante el algoritmo voraz $E_V$ logra un conflicto interno menor ($\approx 13333.33$ frente a $13600$) y cumple con el límite de esfuerzo ($380 \leq 400$). Además, se verificó que esta estrategia también fue identificada por el algoritmo de fuerza bruta como la solución óptima, lo que confirma su calidad.

    \item \textbf{¿Habrá estrategias de moderación no aplicables?} \\
    Sí. Existen muchas estrategias que no son viables porque requieren más esfuerzo del disponible. Por ejemplo, la estrategia $[3, 2, 4]$, que intenta moderar completamente a todos los grupos:
    \[
    \lceil 200 \cdot 0.8 \cdot 3 \rceil + \lceil 20 \cdot 0.5 \cdot 2 \rceil + \lceil 20 \cdot 0.5 \cdot 4 \rceil = 480 + 20 + 40 = 540
    \]
    lo cual supera el presupuesto de $R_{max} = 400$, y por tanto no es aplicable.
\end{itemize}


\subsection{Implementación}

La implementación del algoritmo voraz se realizó empleando una representación estructurada de la red social como una lista de tuplas. Cada tupla representa un grupo de agentes e incluye cuatro elementos: la cantidad de individuos en el grupo, sus opiniones frente a dos afirmaciones específicas y su nivel de rigidez al cambio de opinión.

El proceso se estructura en dos fases principales:

\begin{enumerate}
    \item \textbf{Cálculo de Utilidades y Priorización:} Para cada grupo, se calcula una utilidad basada en una heurística que considera la diferencia entre sus opiniones y su rigidez al cambio. Esta utilidad refleja cuán conveniente sería moderar a un grupo determinado en términos de impacto por unidad de esfuerzo. Luego, todos los grupos son ordenados en orden descendente según esta utilidad.

    \item \textbf{Asignación Voraz de Esfuerzo:} Siguiendo el orden de prioridad determinado, se asigna a cada grupo la cantidad máxima posible de agentes a moderar, respetando el esfuerzo restante disponible. Esta asignación se realiza considerando el costo unitario de moderar un agente en cada grupo, el cual depende de su rigidez y diferencia de opiniones. El proceso continúa hasta agotar el presupuesto de esfuerzo $R_{max}$ o no poder realizar más asignaciones viables.
\end{enumerate}

Al finalizar, la función auxiliar \texttt{calcular\_ci\_esfuerzo} se utiliza para evaluar el conflicto interno y el esfuerzo total correspondiente a la estrategia construida. El resultado final es una tupla que contiene el conflicto interno resultante, el esfuerzo total utilizado y la estrategia voraz de asignación de esfuerzos.

\subsection{Pseudocódigo}
\begin{algorithm}[H]
\caption{modciPV: Estrategia voraz basada en utilidad heurística}
\KwIn{Una red social $RS$ como lista de tuplas $(n_i, op1_i, op2_i, rigidez_i)$ para cada grupo $i$, y un esfuerzo máximo permitido $R_{max}$}
\KwOut{Tupla $(CI, Esfuerzo_{\text{total}}, Estrategia)$}

$estrategia \leftarrow [0, 0, \ldots, 0]$ \tcp*[r]{Inicializar estrategia vacía de tamaño $|RS|$}
$esfuerzoRestante \leftarrow R_{max}$

$utilidades \leftarrow []$ \tcp*[r]{Lista de utilidades heurísticas}

\ForEach{grupo $g_i$ en $RS$}{
    \If{$n_i = 0$}{\textbf{continue}}
    
    $utilidad \leftarrow utilidad\_base(op1_i, op2_i, rigidez_i)$ \\
    $costoUnitario \leftarrow \max(1, \lceil |op1_i - op2_i| \cdot rigidez_i \rceil)$ \\
    $utilidades.\text{append}((utilidad, i, costoUnitario))$
}

$utilidades \leftarrow$ ordenar\_descendente(utilidades, clave=utilidad)

\ForEach{$(utilidad, i, costoUnitario)$ en $utilidades$}{
    \If{$esfuerzoRestante \leq 0$}{\textbf{break}}

    $maxAsignable \leftarrow \min(n_i, \lfloor \frac{esfuerzoRestante}{costoUnitario} \rfloor)$ \\
    $estrategia[i] \leftarrow maxAsignable$ \\
    $esfuerzoRestante \leftarrow esfuerzoRestante - maxAsignable \cdot costoUnitario$
}

$(CI, esfuerzoTotal) \leftarrow calcular\_ci\_esfuerzo(RS, estrategia)$

\Return $(CI, esfuerzoTotal, estrategia)$
\end{algorithm}
\subsection{Complejidad}

\subsubsection{Complejidad temporal}

El algoritmo voraz \texttt{modciPV} realiza las siguientes operaciones principales:

\begin{itemize}
    \item Recorre todos los grupos de la red social (de tamaño $n$) para calcular una utilidad heurística y el esfuerzo unitario por agente. Esto toma ${O}(n)$.
    \item Ordena la lista de grupos por utilidad en orden descendente, lo cual tiene una complejidad de ${O}(n \log n)$.
    \item Itera sobre la lista ordenada para asignar agentes a moderar mientras haya esfuerzo disponible. En el peor caso, esta operación es lineal: ${O}(n)$.
    \item Finalmente, calcula el conflicto interno total y el esfuerzo utilizado, operación que, puede tomar ${O}(n)$.
\end{itemize}

Por lo tanto, la complejidad temporal total está dominada por el ordenamiento de la lista de grupos, lo cual nos da una complejidad de:

\[
{O}(n \log n)
\]

\subsubsection{Complejidad espacial}

Respecto al uso de memoria, el algoritmo:

\begin{itemize}
    \item Almacena información de utilidad por grupo en una lista auxiliar de tamaño $n$.
    \item Genera una lista de estrategias de tamaño $n$ (uno por grupo).
\end{itemize}

No se utilizan estructuras de datos anidadas ni matrices adicionales, por lo que el uso de espacio crece linealmente con el número de grupos.

La complejidad espacial del algoritmo es entonces:

\[
{O}(n)
\]

\subsection{Corrección}

El algoritmo voraz implementado para el problema ModCI proporciona una estrategia de moderación factible dentro del límite de esfuerzo permitido. Para ello, calcula una utilidad heurística para cada grupo de la red social y, en función de este valor, prioriza la asignación de recursos a aquellos grupos que se consideran más "rentables" en términos de impacto por unidad de esfuerzo.

En cada paso, el algoritmo garantiza que:
\begin{itemize}
    \item El esfuerzo total asignado no excede el presupuesto disponible $R_{max}$.
    \item Las asignaciones de agentes a moderar respetan los límites de cada grupo.
    \item La estrategia final generada es válida y puede ser evaluada con la función de conflicto interno.
\end{itemize}

Desde el punto de vista funcional, el algoritmo es correcto, ya que produce soluciones viables que cumplen con las restricciones del problema. No obstante, al tratarse de una heurística, no explora todo el espacio de soluciones posibles, por lo que no garantiza la obtención de la solución óptima global.

A pesar de esta limitación, el enfoque voraz resulta especialmente útil en contextos donde la eficiencia computacional es prioritaria. Gracias a su bajo costo computacional y a su capacidad para generar soluciones razonables en tiempos reducidos, se convierte en una alternativa práctica y escalable frente a enfoques más costosos como la fuerza bruta.

Para evaluar la calidad de sus soluciones, se ejecutó la batería de pruebas comparando los resultados del algoritmo voraz con las soluciones óptimas obtenidas por fuerza bruta o programación dinámica. En cada caso, se calculó el valor relativo de la diferencia mediante la fórmula:

\[
\frac{CI_{\text{voraz}}}{CI_{\text{óptima}}} - 1
\]
\vspace{0.5cm}

A partir de estas pruebas, se obtuvo un promedio de aproximadamente $0{,}0162$, lo cual indica que, en promedio, la solución voraz fue apenas un 1,62\% peor que la óptima. Este bajo margen de desviación sugiere que el algoritmo voraz, aunque no exacto, puede ser altamente competitivo para resolver instancias del problema de forma eficiente.


Teniendo en cuenta las complejidades de los tres enfoques se tiene que el enfoque voraz ofrece una excelente relación entre eficiencia y calidad de solución, especialmente cuando se busca un equilibrio entre rendimiento y precisión en redes sociales de gran tamaño.

\subsubsection{¿Cuándo da la Respuesta Correcta?}
\subsubsection{¿Cuándo no da la Respuesta Correcta?}
\subsection{Análisis}

%%%%%%% ALGORITMO VORAZ %%%%%%% FIN

\newpage

%%%%%%% COMPARACIÓN ALGORITMOS %%%%%%% INICIO
\section{Comparación de Algoritmos}
\subsection{Solución Óptima}
\subsection{Tiempos de Ejecución}
\subsection{Ventajas y Desventajas}
\subsubsection{Fuerza Bruta}
\subsubsection{Dinámico}
\subsubsection{Voraz}
%%%%%%% COMPARACIÓN ALGORITMOS %%%%%%% FIN

\newpage

%%%%%%% CASOS DE PRUEBA %%%%%%% INICIO
\section{Casos de Prueba}
\subsection{Caso de Prueba 1}
\subsection{Caso de Prueba 2}
\subsection{Caso de Prueba 3}
\subsection{Caso de Prueba 4}
\subsection{Caso de Prueba 5}
%%%%%%% CASOS DE PRUEBA %%%%%%% INICIO


\end{document}